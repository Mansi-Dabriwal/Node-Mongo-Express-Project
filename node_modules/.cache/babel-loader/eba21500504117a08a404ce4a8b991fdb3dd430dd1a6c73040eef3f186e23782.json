{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Children } from \"react\";\nimport { isElementOfType } from \"../../common/utils\";\nimport { Hotkey } from \"./hotkey\";\nimport { comboMatches, getKeyCombo, parseKeyCombo } from \"./hotkeyParser\";\nimport { hideHotkeysDialogAfterDelay, isHotkeysDialogShowing, showHotkeysDialog } from \"./hotkeysDialog\";\nvar SHOW_DIALOG_KEY = \"?\";\nexport var HotkeyScope;\n(function (HotkeyScope) {\n  HotkeyScope[\"LOCAL\"] = \"local\";\n  HotkeyScope[\"GLOBAL\"] = \"global\";\n})(HotkeyScope || (HotkeyScope = {}));\nvar HotkeysEvents = /** @class */function () {\n  function HotkeysEvents(scope) {\n    var _this = this;\n    this.scope = scope;\n    this.actions = [];\n    this.handleKeyDown = function (e) {\n      var combo = getKeyCombo(e);\n      var isTextInput = _this.isTextInput(e);\n      if (!isTextInput && comboMatches(parseKeyCombo(SHOW_DIALOG_KEY), combo)) {\n        if (isHotkeysDialogShowing()) {\n          hideHotkeysDialogAfterDelay();\n        } else {\n          showHotkeysDialog(_this.actions.map(function (action) {\n            return action.props;\n          }));\n        }\n        return;\n      } else if (isHotkeysDialogShowing()) {\n        return;\n      }\n      _this.invokeNamedCallbackIfComboRecognized(combo, \"onKeyDown\", e);\n    };\n    this.handleKeyUp = function (e) {\n      if (isHotkeysDialogShowing()) {\n        return;\n      }\n      _this.invokeNamedCallbackIfComboRecognized(getKeyCombo(e), \"onKeyUp\", e);\n    };\n  }\n  HotkeysEvents.prototype.count = function () {\n    return this.actions.length;\n  };\n  HotkeysEvents.prototype.clear = function () {\n    this.actions = [];\n  };\n  HotkeysEvents.prototype.setHotkeys = function (props) {\n    var _this = this;\n    var actions = [];\n    Children.forEach(props.children, function (child) {\n      if (isElementOfType(child, Hotkey) && _this.isScope(child.props)) {\n        actions.push({\n          combo: parseKeyCombo(child.props.combo),\n          props: child.props\n        });\n      }\n    });\n    this.actions = actions;\n  };\n  HotkeysEvents.prototype.invokeNamedCallbackIfComboRecognized = function (combo, callbackName, e) {\n    var _a, _b;\n    var isTextInput = this.isTextInput(e);\n    for (var _i = 0, _c = this.actions; _i < _c.length; _i++) {\n      var action = _c[_i];\n      var shouldIgnore = isTextInput && !action.props.allowInInput || action.props.disabled;\n      if (!shouldIgnore && comboMatches(action.combo, combo)) {\n        if (action.props.preventDefault) {\n          e.preventDefault();\n        }\n        if (action.props.stopPropagation) {\n          // set a flag just for unit testing. not meant to be referenced in feature work.\n          e.isPropagationStopped = true;\n          e.stopPropagation();\n        }\n        (_b = (_a = action.props)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n      }\n    }\n  };\n  HotkeysEvents.prototype.isScope = function (props) {\n    return (props.global ? HotkeyScope.GLOBAL : HotkeyScope.LOCAL) === this.scope;\n  };\n  HotkeysEvents.prototype.isTextInput = function (e) {\n    var elem = e.target;\n    // we check these cases for unit testing, but this should not happen\n    // during normal operation\n    if (elem == null || elem.closest == null) {\n      return false;\n    }\n    var editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n    if (editable == null) {\n      return false;\n    }\n    // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n    if (editable.tagName.toLowerCase() === \"input\") {\n      var inputType = editable.type;\n      if (inputType === \"checkbox\" || inputType === \"radio\") {\n        return false;\n      }\n    }\n    // don't let read-only fields prevent hotkey behavior\n    if (editable.readOnly) {\n      return false;\n    }\n    return true;\n  };\n  return HotkeysEvents;\n}();\nexport { HotkeysEvents };","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAASA,QAAQ,QAAmB,OAAO;AAE3C,SAASC,eAAe,QAAQ,oBAAoB;AACpD,SAASC,MAAM,QAAsB,UAAU;AAC/C,SAASC,YAAY,EAAEC,WAAW,EAAaC,aAAa,QAAQ,gBAAgB;AACpF,SAASC,2BAA2B,EAAEC,sBAAsB,EAAEC,iBAAiB,QAAQ,iBAAiB;AAGxG,IAAMC,eAAe,GAAG,GAAG;AAE3B,WAAYC,WAGX;AAHD,WAAYA,WAAW;EACnBA,8BAAe;EACfA,gCAAiB;AACrB,CAAC,EAHWA,WAAW,KAAXA,WAAW;AAUvB;EAGI,uBAA2BC,KAAkB;IAA7C;IAA2B,UAAK,GAALA,KAAK;IAFxB,YAAO,GAAG,EAAqB;IAyBhC,kBAAa,GAAG,UAACC,CAAgB;MACpC,IAAMC,KAAK,GAAGT,WAAW,CAACQ,CAAC,CAAC;MAC5B,IAAME,WAAW,GAAGC,KAAI,CAACD,WAAW,CAACF,CAAC,CAAC;MAEvC,IAAI,CAACE,WAAW,IAAIX,YAAY,CAACE,aAAa,CAACI,eAAe,CAAC,EAAEI,KAAK,CAAC,EAAE;QACrE,IAAIN,sBAAsB,EAAE,EAAE;UAC1BD,2BAA2B,EAAE;SAChC,MAAM;UACHE,iBAAiB,CAACO,KAAI,CAACC,OAAO,CAACC,GAAG,CAAC,gBAAM;YAAI,aAAM,CAACC,KAAK;UAAZ,CAAY,CAAC,CAAC;;QAE/D;OACH,MAAM,IAAIX,sBAAsB,EAAE,EAAE;QACjC;;MAGJQ,KAAI,CAACI,oCAAoC,CAACN,KAAK,EAAE,WAAW,EAAED,CAAC,CAAC;IACpE,CAAC;IAEM,gBAAW,GAAG,UAACA,CAAgB;MAClC,IAAIL,sBAAsB,EAAE,EAAE;QAC1B;;MAEJQ,KAAI,CAACI,oCAAoC,CAACf,WAAW,CAACQ,CAAC,CAAC,EAAE,SAAS,EAAEA,CAAC,CAAC;IAC3E,CAAC;EA9C+C;EAEzCQ,6BAAK,GAAZ;IACI,OAAO,IAAI,CAACJ,OAAO,CAACK,MAAM;EAC9B,CAAC;EAEMD,6BAAK,GAAZ;IACI,IAAI,CAACJ,OAAO,GAAG,EAAE;EACrB,CAAC;EAEMI,kCAAU,GAAjB,UAAkBF,KAA+C;IAAjE;IACI,IAAMF,OAAO,GAAG,EAAqB;IACrChB,QAAQ,CAACsB,OAAO,CAACJ,KAAK,CAACK,QAAQ,EAAE,UAACC,KAAgB;MAC9C,IAAIvB,eAAe,CAACuB,KAAK,EAAEtB,MAAM,CAAC,IAAIa,KAAI,CAACU,OAAO,CAACD,KAAK,CAACN,KAAK,CAAC,EAAE;QAC7DF,OAAO,CAACU,IAAI,CAAC;UACTb,KAAK,EAAER,aAAa,CAACmB,KAAK,CAACN,KAAK,CAACL,KAAK,CAAC;UACvCK,KAAK,EAAEM,KAAK,CAACN;SAChB,CAAC;;IAEV,CAAC,CAAC;IACF,IAAI,CAACF,OAAO,GAAGA,OAAO;EAC1B,CAAC;EA2BOI,4DAAoC,GAA5C,UACIP,KAAgB,EAChBc,YAAqC,EACrCf,CAAgB;;IAEhB,IAAME,WAAW,GAAG,IAAI,CAACA,WAAW,CAACF,CAAC,CAAC;IACvC,KAAqB,UAAY,EAAZgB,SAAI,CAACZ,OAAO,EAAZa,cAAY,EAAZA,IAAY,EAAE;MAA9B,IAAMC,MAAM;MACb,IAAMC,YAAY,GAAIjB,WAAW,IAAI,CAACgB,MAAM,CAACZ,KAAK,CAACc,YAAY,IAAKF,MAAM,CAACZ,KAAK,CAACe,QAAQ;MACzF,IAAI,CAACF,YAAY,IAAI5B,YAAY,CAAC2B,MAAM,CAACjB,KAAK,EAAEA,KAAK,CAAC,EAAE;QACpD,IAAIiB,MAAM,CAACZ,KAAK,CAACgB,cAAc,EAAE;UAC7BtB,CAAC,CAACsB,cAAc,EAAE;;QAEtB,IAAIJ,MAAM,CAACZ,KAAK,CAACiB,eAAe,EAAE;UAC9B;UACCvB,CAAS,CAACwB,oBAAoB,GAAG,IAAI;UACtCxB,CAAC,CAACuB,eAAe,EAAE;;QAEvB,kBAAM,CAACjB,KAAK,EAACS,YAAY,CAAC,mDAAGf,CAAC,CAAC;;;EAG3C,CAAC;EAEOQ,+BAAO,GAAf,UAAgBF,KAAmB;IAC/B,OAAO,CAACA,KAAK,CAACmB,MAAM,GAAG3B,WAAW,CAAC4B,MAAM,GAAG5B,WAAW,CAAC6B,KAAK,MAAM,IAAI,CAAC5B,KAAK;EACjF,CAAC;EAEOS,mCAAW,GAAnB,UAAoBR,CAAgB;IAChC,IAAM4B,IAAI,GAAG5B,CAAC,CAAC6B,MAAqB;IACpC;IACA;IACA,IAAID,IAAI,IAAI,IAAI,IAAIA,IAAI,CAACE,OAAO,IAAI,IAAI,EAAE;MACtC,OAAO,KAAK;;IAGhB,IAAMC,QAAQ,GAAGH,IAAI,CAACE,OAAO,CAAC,yCAAyC,CAAC;IAExE,IAAIC,QAAQ,IAAI,IAAI,EAAE;MAClB,OAAO,KAAK;;IAGhB;IACA,IAAIA,QAAQ,CAACC,OAAO,CAACC,WAAW,EAAE,KAAK,OAAO,EAAE;MAC5C,IAAMC,SAAS,GAAIH,QAA6B,CAACI,IAAI;MACrD,IAAID,SAAS,KAAK,UAAU,IAAIA,SAAS,KAAK,OAAO,EAAE;QACnD,OAAO,KAAK;;;IAIpB;IACA,IAAKH,QAA6B,CAACK,QAAQ,EAAE;MACzC,OAAO,KAAK;;IAGhB,OAAO,IAAI;EACf,CAAC;EACL,oBAAC;AAAD,CAAC,EA1GD","names":["Children","isElementOfType","Hotkey","comboMatches","getKeyCombo","parseKeyCombo","hideHotkeysDialogAfterDelay","isHotkeysDialogShowing","showHotkeysDialog","SHOW_DIALOG_KEY","HotkeyScope","scope","e","combo","isTextInput","_this","actions","map","props","invokeNamedCallbackIfComboRecognized","HotkeysEvents","length","forEach","children","child","isScope","push","callbackName","_c","_i","action","shouldIgnore","allowInInput","disabled","preventDefault","stopPropagation","isPropagationStopped","global","GLOBAL","LOCAL","elem","target","closest","editable","tagName","toLowerCase","inputType","type","readOnly"],"sources":["/Users/mansidabriwal/Documents/Web design class/React-Assignment/react-app/node_modules/@blueprintjs/core/src/components/hotkeys/hotkeysEvents.ts"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Children, ReactNode } from \"react\";\n\nimport { isElementOfType } from \"../../common/utils\";\nimport { Hotkey, IHotkeyProps } from \"./hotkey\";\nimport { comboMatches, getKeyCombo, IKeyCombo, parseKeyCombo } from \"./hotkeyParser\";\nimport { hideHotkeysDialogAfterDelay, isHotkeysDialogShowing, showHotkeysDialog } from \"./hotkeysDialog\";\nimport { IHotkeysProps } from \"./hotkeysTypes\";\n\nconst SHOW_DIALOG_KEY = \"?\";\n\nexport enum HotkeyScope {\n    LOCAL = \"local\",\n    GLOBAL = \"global\",\n}\n\nexport interface IHotkeyAction {\n    combo: IKeyCombo;\n    props: IHotkeyProps;\n}\n\nexport class HotkeysEvents {\n    private actions = [] as IHotkeyAction[];\n\n    public constructor(private scope: HotkeyScope) {}\n\n    public count() {\n        return this.actions.length;\n    }\n\n    public clear() {\n        this.actions = [];\n    }\n\n    public setHotkeys(props: IHotkeysProps & { children?: ReactNode }) {\n        const actions = [] as IHotkeyAction[];\n        Children.forEach(props.children, (child: ReactNode) => {\n            if (isElementOfType(child, Hotkey) && this.isScope(child.props)) {\n                actions.push({\n                    combo: parseKeyCombo(child.props.combo),\n                    props: child.props,\n                });\n            }\n        });\n        this.actions = actions;\n    }\n\n    public handleKeyDown = (e: KeyboardEvent) => {\n        const combo = getKeyCombo(e);\n        const isTextInput = this.isTextInput(e);\n\n        if (!isTextInput && comboMatches(parseKeyCombo(SHOW_DIALOG_KEY), combo)) {\n            if (isHotkeysDialogShowing()) {\n                hideHotkeysDialogAfterDelay();\n            } else {\n                showHotkeysDialog(this.actions.map(action => action.props));\n            }\n            return;\n        } else if (isHotkeysDialogShowing()) {\n            return;\n        }\n\n        this.invokeNamedCallbackIfComboRecognized(combo, \"onKeyDown\", e);\n    };\n\n    public handleKeyUp = (e: KeyboardEvent) => {\n        if (isHotkeysDialogShowing()) {\n            return;\n        }\n        this.invokeNamedCallbackIfComboRecognized(getKeyCombo(e), \"onKeyUp\", e);\n    };\n\n    private invokeNamedCallbackIfComboRecognized(\n        combo: IKeyCombo,\n        callbackName: \"onKeyDown\" | \"onKeyUp\",\n        e: KeyboardEvent,\n    ) {\n        const isTextInput = this.isTextInput(e);\n        for (const action of this.actions) {\n            const shouldIgnore = (isTextInput && !action.props.allowInInput) || action.props.disabled;\n            if (!shouldIgnore && comboMatches(action.combo, combo)) {\n                if (action.props.preventDefault) {\n                    e.preventDefault();\n                }\n                if (action.props.stopPropagation) {\n                    // set a flag just for unit testing. not meant to be referenced in feature work.\n                    (e as any).isPropagationStopped = true;\n                    e.stopPropagation();\n                }\n                action.props[callbackName]?.(e);\n            }\n        }\n    }\n\n    private isScope(props: IHotkeyProps) {\n        return (props.global ? HotkeyScope.GLOBAL : HotkeyScope.LOCAL) === this.scope;\n    }\n\n    private isTextInput(e: KeyboardEvent) {\n        const elem = e.target as HTMLElement;\n        // we check these cases for unit testing, but this should not happen\n        // during normal operation\n        if (elem == null || elem.closest == null) {\n            return false;\n        }\n\n        const editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n        if (editable == null) {\n            return false;\n        }\n\n        // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n        if (editable.tagName.toLowerCase() === \"input\") {\n            const inputType = (editable as HTMLInputElement).type;\n            if (inputType === \"checkbox\" || inputType === \"radio\") {\n                return false;\n            }\n        }\n\n        // don't let read-only fields prevent hotkey behavior\n        if ((editable as HTMLInputElement).readOnly) {\n            return false;\n        }\n\n        return true;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}