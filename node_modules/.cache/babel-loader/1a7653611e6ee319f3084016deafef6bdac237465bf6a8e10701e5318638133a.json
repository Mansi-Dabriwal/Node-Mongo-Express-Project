{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Boundary } from \"../../common/boundary\";\nimport * as Classes from \"../../common/classes\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\nvar OverflowList = /** @class */function (_super) {\n  __extends(OverflowList, _super);\n  function OverflowList() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      chopSize: _this.defaultChopSize(),\n      lastChopSize: null,\n      lastOverflowCount: 0,\n      overflow: [],\n      repartitioning: false,\n      visible: _this.props.items\n    };\n    _this.spacer = null;\n    _this.resize = function () {\n      _this.repartition();\n    };\n    return _this;\n  }\n  OverflowList.ofType = function () {\n    return OverflowList;\n  };\n  OverflowList.prototype.componentDidMount = function () {\n    this.repartition();\n  };\n  OverflowList.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    // We want this component to always re-render, even when props haven't changed, so that\n    // changes in the renderers' behavior can be reflected.\n    // The following statement prevents re-rendering only in the case where the state changes\n    // identity (i.e. setState was called), but the state is still the same when\n    // shallow-compared to the previous state. Original context: https://github.com/palantir/blueprint/pull/3278.\n    // We also ensure that we re-render if the props DO change (which isn't necessarily accounted for by other logic).\n    return this.props !== nextProps || !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n  };\n  OverflowList.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b;\n    if (prevProps.observeParents !== this.props.observeParents) {\n      console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n    }\n    if (prevProps.collapseFrom !== this.props.collapseFrom || prevProps.items !== this.props.items || prevProps.minVisibleItems !== this.props.minVisibleItems || prevProps.overflowRenderer !== this.props.overflowRenderer || prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow || prevProps.visibleItemRenderer !== this.props.visibleItemRenderer) {\n      // reset visible state if the above props change.\n      this.setState({\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        lastOverflowCount: 0,\n        overflow: [],\n        repartitioning: true,\n        visible: this.props.items\n      });\n    }\n    var _c = this.state,\n      repartitioning = _c.repartitioning,\n      overflow = _c.overflow,\n      lastOverflowCount = _c.lastOverflowCount;\n    if (\n    // if a resize operation has just completed\n    repartitioning === false && prevState.repartitioning === true) {\n      // only invoke the callback if the UI has actually changed\n      if (overflow.length !== lastOverflowCount) {\n        (_b = (_a = this.props).onOverflow) === null || _b === void 0 ? void 0 : _b.call(_a, overflow.slice());\n      }\n    } else if (!shallowCompareKeys(prevState, this.state)) {\n      this.repartition();\n    }\n  };\n  OverflowList.prototype.render = function () {\n    var _this = this;\n    var _a = this.props,\n      className = _a.className,\n      collapseFrom = _a.collapseFrom,\n      observeParents = _a.observeParents,\n      style = _a.style,\n      _b = _a.tagName,\n      tagName = _b === void 0 ? \"div\" : _b,\n      visibleItemRenderer = _a.visibleItemRenderer;\n    var overflow = this.maybeRenderOverflow();\n    var list = React.createElement(tagName, {\n      className: classNames(Classes.OVERFLOW_LIST, className),\n      style: style\n    }, collapseFrom === Boundary.START ? overflow : null, this.state.visible.map(visibleItemRenderer), collapseFrom === Boundary.END ? overflow : null, React.createElement(\"div\", {\n      className: Classes.OVERFLOW_LIST_SPACER,\n      ref: function (ref) {\n        return _this.spacer = ref;\n      }\n    }));\n    return React.createElement(ResizeSensor, {\n      onResize: this.resize,\n      observeParents: observeParents\n    }, list);\n  };\n  OverflowList.prototype.maybeRenderOverflow = function () {\n    var overflow = this.state.overflow;\n    if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {\n      return null;\n    }\n    return this.props.overflowRenderer(overflow.slice());\n  };\n  OverflowList.prototype.repartition = function () {\n    var _this = this;\n    var _a;\n    if (this.spacer == null) {\n      return;\n    }\n    // if lastChopSize was 1, then our binary search has exhausted.\n    var partitionExhausted = this.state.lastChopSize === 1;\n    var minVisible = (_a = this.props.minVisibleItems) !== null && _a !== void 0 ? _a : 0;\n    // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n    var shouldShrink = this.spacer.offsetWidth < 0.9 && this.state.visible.length > minVisible;\n    // we only check partitionExhausted for shouldGrow to ensure shrinking is the final operation.\n    var shouldGrow = (this.spacer.offsetWidth >= 1 || this.state.visible.length < minVisible) && this.state.overflow.length > 0 && !partitionExhausted;\n    if (shouldShrink || shouldGrow) {\n      this.setState(function (state) {\n        var visible;\n        var overflow;\n        if (_this.props.collapseFrom === Boundary.END) {\n          var result = shiftElements(state.visible, state.overflow, _this.state.chopSize * (shouldShrink ? 1 : -1));\n          visible = result[0];\n          overflow = result[1];\n        } else {\n          var result = shiftElements(state.overflow, state.visible, _this.state.chopSize * (shouldShrink ? -1 : 1));\n          overflow = result[0];\n          visible = result[1];\n        }\n        return {\n          chopSize: halve(state.chopSize),\n          lastChopSize: state.chopSize,\n          // if we're starting a new partition cycle, record the last overflow count so we can track whether the UI changes after the new overflow is calculated\n          lastOverflowCount: _this.isFirstPartitionCycle(state.chopSize) ? state.overflow.length : state.lastOverflowCount,\n          overflow: overflow,\n          repartitioning: true,\n          visible: visible\n        };\n      });\n    } else {\n      // repartition complete!\n      this.setState({\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        repartitioning: false\n      });\n    }\n  };\n  OverflowList.prototype.defaultChopSize = function () {\n    return halve(this.props.items.length);\n  };\n  OverflowList.prototype.isFirstPartitionCycle = function (currentChopSize) {\n    return currentChopSize === this.defaultChopSize();\n  };\n  OverflowList.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".OverflowList\");\n  OverflowList.defaultProps = {\n    alwaysRenderOverflow: false,\n    collapseFrom: Boundary.START,\n    minVisibleItems: 0\n  };\n  return OverflowList;\n}(React.Component);\nexport { OverflowList };\nfunction halve(num) {\n  return Math.ceil(num / 2);\n}\nfunction shiftElements(leftArray, rightArray, num) {\n  // if num is positive then elements are shifted from left-to-right, if negative then right-to-left\n  var allElements = leftArray.concat(rightArray);\n  var newLeftLength = leftArray.length - num;\n  if (newLeftLength <= 0) {\n    return [[], allElements];\n  } else if (newLeftLength >= allElements.length) {\n    return [allElements, []];\n  }\n  var sliceIndex = allElements.length - newLeftLength;\n  return [allElements.slice(0, -sliceIndex), allElements.slice(-sliceIndex)];\n}","map":{"version":3,"mappings":"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","names":["classNames","React","Boundary","Classes","OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED","DISPLAYNAME_PREFIX","shallowCompareKeys","ResizeSensor","__extends","_this","chopSize","defaultChopSize","lastChopSize","lastOverflowCount","overflow","repartitioning","visible","props","items","repartition","OverflowList","nextProps","nextState","state","prevProps","prevState","observeParents","console","warn","collapseFrom","minVisibleItems","overflowRenderer","alwaysRenderOverflow","visibleItemRenderer","setState","length","onOverflow","slice","className","style","_b","tagName","maybeRenderOverflow","list","createElement","OVERFLOW_LIST","START","map","END","OVERFLOW_LIST_SPACER","ref","spacer","onResize","resize","partitionExhausted","minVisible","shouldShrink","offsetWidth","shouldGrow","result","shiftElements","halve","isFirstPartitionCycle","currentChopSize","Component","num","Math","ceil","leftArray","rightArray","allElements","concat","newLeftLength","sliceIndex"],"sources":["/Users/mansidabriwal/Documents/Web design class/React-Assignment/react-app/node_modules/@blueprintjs/core/src/components/overflow-list/overflowList.tsx"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { Boundary } from \"../../common/boundary\";\nimport * as Classes from \"../../common/classes\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, Props } from \"../../common/props\";\nimport { shallowCompareKeys } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type OverflowListProps<T> = IOverflowListProps<T>;\n/** @deprecated use OverflowListProps */\nexport interface IOverflowListProps<T> extends Props {\n    /**\n     * Whether to force the overflowRenderer to always be called, even if there are zero items\n     * overflowing. This may be useful, for example, if your overflow renderer contains a Popover\n     * which you do not want to close as the list is resized.\n     *\n     * @default false\n     */\n    alwaysRenderOverflow?: boolean;\n\n    /**\n     * Which direction the items should collapse from: start or end of the\n     * children. This also determines whether `overflowRenderer` appears before\n     * (`START`) or after (`END`) the visible items.\n     *\n     * @default Boundary.START\n     */\n    collapseFrom?: Boundary;\n\n    /**\n     * All items to display in the list. Items that do not fit in the container\n     * will be rendered in the overflow instead.\n     */\n    items: readonly T[];\n\n    /**\n     * The minimum number of visible items that should never collapse into the\n     * overflow menu, regardless of DOM dimensions.\n     *\n     * @default 0\n     */\n    minVisibleItems?: number;\n\n    /**\n     * If `true`, all parent DOM elements of the container will also be\n     * observed. If changes to a parent's size is detected, the overflow will be\n     * recalculated.\n     *\n     * Only enable this prop if the overflow should be recalculated when a\n     * parent element resizes in a way that does not also cause the\n     * `OverflowList` to resize.\n     *\n     * @default false\n     */\n    observeParents?: boolean;\n\n    /**\n     * Callback invoked when the overflowed items change. This is called once\n     * after the DOM has settled, rather that on every intermediate change. It\n     * is not invoked if resizing produces an unchanged overflow state.\n     */\n    onOverflow?: (overflowItems: T[]) => void;\n\n    /**\n     * Callback invoked to render the overflowed items. Unlike\n     * `visibleItemRenderer`, this prop is invoked once with all items that do\n     * not fit in the container.\n     *\n     * Typical use cases for this prop will put overflowed items in a dropdown\n     * menu or display a \"+X items\" label.\n     */\n    overflowRenderer: (overflowItems: T[]) => React.ReactNode;\n\n    /** CSS properties to apply to the root element. */\n    style?: React.CSSProperties;\n\n    /**\n     * HTML tag name for the container element.\n     *\n     * @default \"div\"\n     */\n    tagName?: keyof JSX.IntrinsicElements;\n\n    /**\n     * Callback invoked to render each visible item.\n     * Remember to set a `key` on the rendered element!\n     */\n    visibleItemRenderer: (item: T, index: number) => React.ReactChild;\n}\n\nexport interface IOverflowListState<T> {\n    /** Whether repartitioning is still active. An overflow can take several frames to settle. */\n    repartitioning: boolean;\n    /** Length of last overflow to dedupe `onOverflow` calls during smooth resizing. */\n    lastOverflowCount: number;\n    overflow: readonly T[];\n    visible: readonly T[];\n    /** Pointer for the binary search algorithm used to find the finished non-overflowing state */\n    chopSize: number;\n    lastChopSize: number | null;\n}\n\nexport class OverflowList<T> extends React.Component<OverflowListProps<T>, IOverflowListState<T>> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.OverflowList`;\n\n    public static defaultProps: Partial<OverflowListProps<any>> = {\n        alwaysRenderOverflow: false,\n        collapseFrom: Boundary.START,\n        minVisibleItems: 0,\n    };\n\n    public static ofType<U>() {\n        return OverflowList as new (props: OverflowListProps<U>) => OverflowList<U>;\n    }\n\n    public state: IOverflowListState<T> = {\n        chopSize: this.defaultChopSize(),\n        lastChopSize: null,\n        lastOverflowCount: 0,\n        overflow: [],\n        repartitioning: false,\n        visible: this.props.items,\n    };\n\n    private spacer: HTMLElement | null = null;\n\n    public componentDidMount() {\n        this.repartition();\n    }\n\n    public shouldComponentUpdate(nextProps: OverflowListProps<T>, nextState: IOverflowListState<T>) {\n        // We want this component to always re-render, even when props haven't changed, so that\n        // changes in the renderers' behavior can be reflected.\n        // The following statement prevents re-rendering only in the case where the state changes\n        // identity (i.e. setState was called), but the state is still the same when\n        // shallow-compared to the previous state. Original context: https://github.com/palantir/blueprint/pull/3278.\n        // We also ensure that we re-render if the props DO change (which isn't necessarily accounted for by other logic).\n        return this.props !== nextProps || !(this.state !== nextState && shallowCompareKeys(this.state, nextState));\n    }\n\n    public componentDidUpdate(prevProps: OverflowListProps<T>, prevState: IOverflowListState<T>) {\n        if (prevProps.observeParents !== this.props.observeParents) {\n            console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n        }\n\n        if (\n            prevProps.collapseFrom !== this.props.collapseFrom ||\n            prevProps.items !== this.props.items ||\n            prevProps.minVisibleItems !== this.props.minVisibleItems ||\n            prevProps.overflowRenderer !== this.props.overflowRenderer ||\n            prevProps.alwaysRenderOverflow !== this.props.alwaysRenderOverflow ||\n            prevProps.visibleItemRenderer !== this.props.visibleItemRenderer\n        ) {\n            // reset visible state if the above props change.\n            this.setState({\n                chopSize: this.defaultChopSize(),\n                lastChopSize: null,\n                lastOverflowCount: 0,\n                overflow: [],\n                repartitioning: true,\n                visible: this.props.items,\n            });\n        }\n\n        const { repartitioning, overflow, lastOverflowCount } = this.state;\n\n        if (\n            // if a resize operation has just completed\n            repartitioning === false &&\n            prevState.repartitioning === true\n        ) {\n            // only invoke the callback if the UI has actually changed\n            if (overflow.length !== lastOverflowCount) {\n                this.props.onOverflow?.(overflow.slice());\n            }\n        } else if (!shallowCompareKeys(prevState, this.state)) {\n            this.repartition();\n        }\n    }\n\n    public render() {\n        const { className, collapseFrom, observeParents, style, tagName = \"div\", visibleItemRenderer } = this.props;\n        const overflow = this.maybeRenderOverflow();\n        const list = React.createElement(\n            tagName,\n            {\n                className: classNames(Classes.OVERFLOW_LIST, className),\n                style,\n            },\n            collapseFrom === Boundary.START ? overflow : null,\n            this.state.visible.map(visibleItemRenderer),\n            collapseFrom === Boundary.END ? overflow : null,\n            <div className={Classes.OVERFLOW_LIST_SPACER} ref={ref => (this.spacer = ref)} />,\n        );\n\n        return (\n            <ResizeSensor onResize={this.resize} observeParents={observeParents}>\n                {list}\n            </ResizeSensor>\n        );\n    }\n\n    private maybeRenderOverflow() {\n        const { overflow } = this.state;\n        if (overflow.length === 0 && !this.props.alwaysRenderOverflow) {\n            return null;\n        }\n        return this.props.overflowRenderer(overflow.slice());\n    }\n\n    private resize = () => {\n        this.repartition();\n    };\n\n    private repartition() {\n        if (this.spacer == null) {\n            return;\n        }\n\n        // if lastChopSize was 1, then our binary search has exhausted.\n        const partitionExhausted = this.state.lastChopSize === 1;\n        const minVisible = this.props.minVisibleItems ?? 0;\n\n        // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n        const shouldShrink = this.spacer.offsetWidth < 0.9 && this.state.visible.length > minVisible;\n\n        // we only check partitionExhausted for shouldGrow to ensure shrinking is the final operation.\n        const shouldGrow =\n            (this.spacer.offsetWidth >= 1 || this.state.visible.length < minVisible) &&\n            this.state.overflow.length > 0 &&\n            !partitionExhausted;\n\n        if (shouldShrink || shouldGrow) {\n            this.setState(state => {\n                let visible;\n                let overflow;\n                if (this.props.collapseFrom === Boundary.END) {\n                    const result = shiftElements(\n                        state.visible,\n                        state.overflow,\n                        this.state.chopSize * (shouldShrink ? 1 : -1),\n                    );\n                    visible = result[0];\n                    overflow = result[1];\n                } else {\n                    const result = shiftElements(\n                        state.overflow,\n                        state.visible,\n                        this.state.chopSize * (shouldShrink ? -1 : 1),\n                    );\n                    overflow = result[0];\n                    visible = result[1];\n                }\n\n                return {\n                    chopSize: halve(state.chopSize),\n                    lastChopSize: state.chopSize,\n                    // if we're starting a new partition cycle, record the last overflow count so we can track whether the UI changes after the new overflow is calculated\n                    lastOverflowCount: this.isFirstPartitionCycle(state.chopSize)\n                        ? state.overflow.length\n                        : state.lastOverflowCount,\n                    overflow,\n                    repartitioning: true,\n                    visible,\n                };\n            });\n        } else {\n            // repartition complete!\n            this.setState({\n                chopSize: this.defaultChopSize(),\n                lastChopSize: null,\n                repartitioning: false,\n            });\n        }\n    }\n\n    private defaultChopSize(): number {\n        return halve(this.props.items.length);\n    }\n\n    private isFirstPartitionCycle(currentChopSize: number): boolean {\n        return currentChopSize === this.defaultChopSize();\n    }\n}\n\nfunction halve(num: number): number {\n    return Math.ceil(num / 2);\n}\n\nfunction shiftElements<T>(leftArray: readonly T[], rightArray: readonly T[], num: number): [newFrom: T[], newTo: T[]] {\n    // if num is positive then elements are shifted from left-to-right, if negative then right-to-left\n    const allElements = leftArray.concat(rightArray);\n    const newLeftLength = leftArray.length - num;\n\n    if (newLeftLength <= 0) {\n        return [[], allElements];\n    } else if (newLeftLength >= allElements.length) {\n        return [allElements, []];\n    }\n\n    const sliceIndex = allElements.length - newLeftLength;\n\n    return [allElements.slice(0, -sliceIndex), allElements.slice(-sliceIndex)];\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}