{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends, __rest } from \"tslib\";\n// we need some empty interfaces to show up in docs\n// HACKHACK: these components should go in separate files\n/* eslint-disable max-classes-per-file, @typescript-eslint/no-empty-interface */\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, refHandler, setRef } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\n/**\n * Renders common control elements, with additional props to customize appearance.\n * This component is not exported and is only used in this file for `Checkbox`, `Radio`, and `Switch` below.\n */\nvar Control = function (_a) {\n  var _b;\n  var alignIndicator = _a.alignIndicator,\n    children = _a.children,\n    className = _a.className,\n    indicatorChildren = _a.indicatorChildren,\n    inline = _a.inline,\n    inputRef = _a.inputRef,\n    label = _a.label,\n    labelElement = _a.labelElement,\n    large = _a.large,\n    style = _a.style,\n    type = _a.type,\n    typeClassName = _a.typeClassName,\n    _c = _a.tagName,\n    tagName = _c === void 0 ? \"label\" : _c,\n    htmlProps = __rest(_a, [\"alignIndicator\", \"children\", \"className\", \"indicatorChildren\", \"inline\", \"inputRef\", \"label\", \"labelElement\", \"large\", \"style\", \"type\", \"typeClassName\", \"tagName\"]);\n  var classes = classNames(Classes.CONTROL, typeClassName, (_b = {}, _b[Classes.DISABLED] = htmlProps.disabled, _b[Classes.INLINE] = inline, _b[Classes.LARGE] = large, _b), Classes.alignmentClass(alignIndicator), className);\n  return React.createElement(tagName, {\n    className: classes,\n    style: style\n  }, React.createElement(\"input\", __assign({}, htmlProps, {\n    ref: inputRef,\n    type: type\n  })), React.createElement(\"span\", {\n    className: Classes.CONTROL_INDICATOR\n  }, indicatorChildren), label, labelElement, children);\n};\nvar Switch = /** @class */function (_super) {\n  __extends(Switch, _super);\n  function Switch() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Switch.prototype.render = function () {\n    var _a = this.props,\n      innerLabelChecked = _a.innerLabelChecked,\n      innerLabel = _a.innerLabel,\n      controlProps = __rest(_a, [\"innerLabelChecked\", \"innerLabel\"]);\n    var switchLabels = innerLabel || innerLabelChecked ? [React.createElement(\"div\", {\n      key: \"checked\",\n      className: Classes.CONTROL_INDICATOR_CHILD\n    }, React.createElement(\"div\", {\n      className: Classes.SWITCH_INNER_TEXT\n    }, innerLabelChecked ? innerLabelChecked : innerLabel)), React.createElement(\"div\", {\n      key: \"unchecked\",\n      className: Classes.CONTROL_INDICATOR_CHILD\n    }, React.createElement(\"div\", {\n      className: Classes.SWITCH_INNER_TEXT\n    }, innerLabel))] : null;\n    return React.createElement(Control, __assign({}, controlProps, {\n      type: \"checkbox\",\n      typeClassName: Classes.SWITCH,\n      indicatorChildren: switchLabels\n    }));\n  };\n  Switch.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Switch\");\n  return Switch;\n}(AbstractPureComponent2);\nexport { Switch };\nvar Radio = /** @class */function (_super) {\n  __extends(Radio, _super);\n  function Radio() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Radio.prototype.render = function () {\n    return React.createElement(Control, __assign({}, this.props, {\n      type: \"radio\",\n      typeClassName: Classes.RADIO\n    }));\n  };\n  Radio.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Radio\");\n  return Radio;\n}(AbstractPureComponent2);\nexport { Radio };\nvar Checkbox = /** @class */function (_super) {\n  __extends(Checkbox, _super);\n  function Checkbox() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      indeterminate: _this.props.indeterminate || _this.props.defaultIndeterminate || false\n    };\n    // must maintain internal reference for `indeterminate` support\n    _this.input = null;\n    _this.handleInputRef = refHandler(_this, \"input\", _this.props.inputRef);\n    _this.handleChange = function (evt) {\n      var _a, _b;\n      var indeterminate = evt.target.indeterminate;\n      // update state immediately only if uncontrolled\n      if (_this.props.indeterminate == null) {\n        _this.setState({\n          indeterminate: indeterminate\n        });\n      }\n      // otherwise wait for props change. always invoke handler.\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, evt);\n    };\n    return _this;\n  }\n  Checkbox.getDerivedStateFromProps = function (_a) {\n    var indeterminate = _a.indeterminate;\n    // put props into state if controlled by props\n    if (indeterminate != null) {\n      return {\n        indeterminate: indeterminate\n      };\n    }\n    return null;\n  };\n  Checkbox.prototype.render = function () {\n    var _a = this.props,\n      defaultIndeterminate = _a.defaultIndeterminate,\n      indeterminate = _a.indeterminate,\n      controlProps = __rest(_a, [\"defaultIndeterminate\", \"indeterminate\"]);\n    return React.createElement(Control, __assign({}, controlProps, {\n      inputRef: this.handleInputRef,\n      onChange: this.handleChange,\n      type: \"checkbox\",\n      typeClassName: Classes.CHECKBOX\n    }));\n  };\n  Checkbox.prototype.componentDidMount = function () {\n    this.updateIndeterminate();\n  };\n  Checkbox.prototype.componentDidUpdate = function (prevProps) {\n    this.updateIndeterminate();\n    if (prevProps.inputRef !== this.props.inputRef) {\n      setRef(prevProps.inputRef, null);\n      this.handleInputRef = refHandler(this, \"input\", this.props.inputRef);\n      setRef(this.props.inputRef, this.input);\n    }\n  };\n  Checkbox.prototype.updateIndeterminate = function () {\n    if (this.input != null) {\n      this.input.indeterminate = this.state.indeterminate;\n    }\n  };\n  Checkbox.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Checkbox\");\n  return Checkbox;\n}(AbstractPureComponent2);\nexport { Checkbox };","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","refHandler","setRef","DISPLAYNAME_PREFIX","Control","_a","children","className","indicatorChildren","inline","inputRef","label","labelElement","large","style","type","typeClassName","_c","tagName","htmlProps","classes","CONTROL","_b","DISABLED","disabled","INLINE","LARGE","alignmentClass","alignIndicator","createElement","ref","CONTROL_INDICATOR","__extends","Switch","props","innerLabelChecked","innerLabel","controlProps","switchLabels","key","CONTROL_INDICATOR_CHILD","SWITCH_INNER_TEXT","SWITCH","Radio","RADIO","_this","indeterminate","defaultIndeterminate","evt","target","setState","onChange","Checkbox","handleInputRef","handleChange","CHECKBOX","updateIndeterminate","prevProps","input","state"],"sources":["/Users/mansidabriwal/Documents/Web design class/React-Assignment/react-app/node_modules/@blueprintjs/core/src/components/forms/controls.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// we need some empty interfaces to show up in docs\n// HACKHACK: these components should go in separate files\n/* eslint-disable max-classes-per-file, @typescript-eslint/no-empty-interface */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Alignment, Classes, refHandler, setRef } from \"../../common\";\nimport { DISPLAYNAME_PREFIX, HTMLInputProps, Props } from \"../../common/props\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type ControlProps = IControlProps;\n/** @deprecated use ControlProps */\nexport interface IControlProps extends Props, HTMLInputProps {\n    // NOTE: HTML props are duplicated here to provide control-specific documentation\n\n    /**\n     * Alignment of the indicator within container.\n     *\n     * @default Alignment.LEFT\n     */\n    alignIndicator?: Alignment;\n\n    /** Whether the control is checked. */\n    checked?: boolean;\n\n    /** JSX label for the control. */\n    children?: React.ReactNode;\n\n    /** Whether the control is initially checked (uncontrolled mode). */\n    defaultChecked?: boolean;\n\n    /** Whether the control is non-interactive. */\n    disabled?: boolean;\n\n    /** Ref handler that receives HTML `<input>` element backing this component. */\n    inputRef?: React.Ref<HTMLInputElement>;\n\n    /** Whether the control should appear as an inline element. */\n    inline?: boolean;\n\n    /**\n     * Text label for the control.\n     *\n     * Use `children` or `labelElement` to supply JSX content. This prop actually supports JSX elements,\n     * but TypeScript will throw an error because `HTMLAttributes` only allows strings.\n     */\n    label?: string;\n\n    /**\n     * JSX Element label for the control.\n     *\n     * This prop is a workaround for TypeScript consumers as the type definition for `label` only\n     * accepts strings. JavaScript consumers can provide a JSX element directly to `label`.\n     */\n    labelElement?: React.ReactNode;\n\n    /** Whether this control should use large styles. */\n    large?: boolean;\n\n    /** Event handler invoked when input value is changed. */\n    onChange?: React.FormEventHandler<HTMLInputElement>;\n\n    /**\n     * Name of the HTML tag that wraps the checkbox.\n     *\n     * By default a `<label>` is used, which effectively enlarges the click\n     * target to include all of its children. Supply a different tag name if\n     * this behavior is undesirable or you're listening to click events from a\n     * parent element (as the label can register duplicate clicks).\n     *\n     * @default \"label\"\n     */\n    tagName?: keyof JSX.IntrinsicElements;\n}\n\n/** Internal props for Checkbox/Radio/Switch to render correctly. */\ninterface IControlInternalProps extends ControlProps {\n    type: \"checkbox\" | \"radio\";\n    typeClassName: string;\n    indicatorChildren?: React.ReactNode;\n}\n\n/**\n * Renders common control elements, with additional props to customize appearance.\n * This component is not exported and is only used in this file for `Checkbox`, `Radio`, and `Switch` below.\n */\nconst Control: React.FC<IControlInternalProps> = ({\n    alignIndicator,\n    children,\n    className,\n    indicatorChildren,\n    inline,\n    inputRef,\n    label,\n    labelElement,\n    large,\n    style,\n    type,\n    typeClassName,\n    tagName = \"label\",\n    ...htmlProps\n}) => {\n    const classes = classNames(\n        Classes.CONTROL,\n        typeClassName,\n        {\n            [Classes.DISABLED]: htmlProps.disabled,\n            [Classes.INLINE]: inline,\n            [Classes.LARGE]: large,\n        },\n        Classes.alignmentClass(alignIndicator),\n        className,\n    );\n\n    return React.createElement(\n        tagName,\n        { className: classes, style },\n        <input {...htmlProps} ref={inputRef} type={type} />,\n        <span className={Classes.CONTROL_INDICATOR}>{indicatorChildren}</span>,\n        label,\n        labelElement,\n        children,\n    );\n};\n\n//\n// Switch\n//\n\n// eslint-disable-next-line deprecation/deprecation\nexport type SwitchProps = ISwitchProps;\n/** @deprecated use SwitchProps */\nexport interface ISwitchProps extends ControlProps {\n    /**\n     * Text to display inside the switch indicator when checked.\n     * If `innerLabel` is provided and this prop is omitted, then `innerLabel`\n     * will be used for both states.\n     *\n     * @default innerLabel\n     */\n    innerLabelChecked?: string;\n\n    /**\n     * Text to display inside the switch indicator when unchecked.\n     */\n    innerLabel?: string;\n}\n\nexport class Switch extends AbstractPureComponent2<SwitchProps> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Switch`;\n\n    public render() {\n        const { innerLabelChecked, innerLabel, ...controlProps } = this.props;\n        const switchLabels =\n            innerLabel || innerLabelChecked\n                ? [\n                      <div key=\"checked\" className={Classes.CONTROL_INDICATOR_CHILD}>\n                          <div className={Classes.SWITCH_INNER_TEXT}>\n                              {innerLabelChecked ? innerLabelChecked : innerLabel}\n                          </div>\n                      </div>,\n                      <div key=\"unchecked\" className={Classes.CONTROL_INDICATOR_CHILD}>\n                          <div className={Classes.SWITCH_INNER_TEXT}>{innerLabel}</div>\n                      </div>,\n                  ]\n                : null;\n        return (\n            <Control\n                {...controlProps}\n                type=\"checkbox\"\n                typeClassName={Classes.SWITCH}\n                indicatorChildren={switchLabels}\n            />\n        );\n    }\n}\n\n//\n// Radio\n//\n\n/** @deprecated use RadioProps */\nexport type IRadioProps = ControlProps;\n// eslint-disable-next-line deprecation/deprecation\nexport type RadioProps = IRadioProps;\n\nexport class Radio extends AbstractPureComponent2<RadioProps> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Radio`;\n\n    public render() {\n        return <Control {...this.props} type=\"radio\" typeClassName={Classes.RADIO} />;\n    }\n}\n\n//\n// Checkbox\n//\n\n// eslint-disable-next-line deprecation/deprecation\nexport type CheckboxProps = ICheckboxProps;\n/** @deprecated use CheckboxProps */\nexport interface ICheckboxProps extends ControlProps {\n    /** Whether this checkbox is initially indeterminate (uncontrolled mode). */\n    defaultIndeterminate?: boolean;\n\n    /**\n     * Whether this checkbox is indeterminate, or \"partially checked.\"\n     * The checkbox will appear with a small dash instead of a tick to indicate that the value\n     * is not exactly true or false.\n     *\n     * Note that this prop takes precendence over `checked`: if a checkbox is marked both\n     * `checked` and `indeterminate` via props, it will appear as indeterminate in the DOM.\n     */\n    indeterminate?: boolean;\n}\n\nexport interface ICheckboxState {\n    // Checkbox adds support for uncontrolled indeterminate state\n    indeterminate: boolean;\n}\n\nexport class Checkbox extends AbstractPureComponent2<CheckboxProps, ICheckboxState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Checkbox`;\n\n    public static getDerivedStateFromProps({ indeterminate }: CheckboxProps): ICheckboxState | null {\n        // put props into state if controlled by props\n        if (indeterminate != null) {\n            return { indeterminate };\n        }\n\n        return null;\n    }\n\n    public state: ICheckboxState = {\n        indeterminate: this.props.indeterminate || this.props.defaultIndeterminate || false,\n    };\n\n    // must maintain internal reference for `indeterminate` support\n    public input: HTMLInputElement | null = null;\n\n    private handleInputRef: React.Ref<HTMLInputElement> = refHandler(this, \"input\", this.props.inputRef);\n\n    public render() {\n        const { defaultIndeterminate, indeterminate, ...controlProps } = this.props;\n        return (\n            <Control\n                {...controlProps}\n                inputRef={this.handleInputRef}\n                onChange={this.handleChange}\n                type=\"checkbox\"\n                typeClassName={Classes.CHECKBOX}\n            />\n        );\n    }\n\n    public componentDidMount() {\n        this.updateIndeterminate();\n    }\n\n    public componentDidUpdate(prevProps: CheckboxProps) {\n        this.updateIndeterminate();\n        if (prevProps.inputRef !== this.props.inputRef) {\n            setRef(prevProps.inputRef, null);\n            this.handleInputRef = refHandler(this, \"input\", this.props.inputRef);\n            setRef(this.props.inputRef, this.input);\n        }\n    }\n\n    private updateIndeterminate() {\n        if (this.input != null) {\n            this.input.indeterminate = this.state.indeterminate;\n        }\n    }\n\n    private handleChange = (evt: React.ChangeEvent<HTMLInputElement>) => {\n        const { indeterminate } = evt.target;\n        // update state immediately only if uncontrolled\n        if (this.props.indeterminate == null) {\n            this.setState({ indeterminate });\n        }\n        // otherwise wait for props change. always invoke handler.\n        this.props.onChange?.(evt);\n    };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}