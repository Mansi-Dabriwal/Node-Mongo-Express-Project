{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends, __rest } from \"tslib\";\n/**\n * @fileoverview This component is DEPRECATED, and the code is frozen.\n * All changes & bugfixes should be made to ContextMenu2 instead.\n */\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { AbstractPureComponent2, Classes, Position } from \"../../common\";\nimport { Popover } from \"../popover/popover\";\nvar POPPER_MODIFIERS = {\n  preventOverflow: {\n    boundariesElement: \"viewport\"\n  }\n};\nvar TRANSITION_DURATION = 100;\n/* istanbul ignore next */\n/** @deprecated use ContextMenu2 */\nvar ContextMenu = /** @class */function (_super) {\n  __extends(ContextMenu, _super);\n  function ContextMenu() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      isDarkTheme: false,\n      isOpen: false\n    };\n    _this.cancelContextMenu = function (e) {\n      return e.preventDefault();\n    };\n    _this.handleBackdropContextMenu = function (e) {\n      // React function to remove from the event pool, useful when using a event within a callback\n      e.persist();\n      e.preventDefault();\n      // wait for backdrop to disappear so we can find the \"real\" element at event coordinates.\n      // timeout duration is equivalent to transition duration so we know it's animated out.\n      _this.setTimeout(function () {\n        // retrigger context menu event at the element beneath the backdrop.\n        // if it has a `contextmenu` event handler then it'll be invoked.\n        // if it doesn't, no native menu will show (at least on OSX) :(\n        var newTarget = document.elementFromPoint(e.clientX, e.clientY);\n        var view = e.view,\n          newEventInit = __rest(e, [\"view\"]);\n        newTarget === null || newTarget === void 0 ? void 0 : newTarget.dispatchEvent(new MouseEvent(\"contextmenu\", newEventInit));\n      }, TRANSITION_DURATION);\n    };\n    _this.handlePopoverInteraction = function (nextOpenState) {\n      if (!nextOpenState) {\n        // delay the actual hiding till the event queue clears\n        // to avoid flicker of opening twice\n        _this.requestAnimationFrame(function () {\n          return _this.hide();\n        });\n      }\n    };\n    return _this;\n  }\n  ContextMenu.prototype.render = function () {\n    var _a;\n    // prevent right-clicking in a context menu\n    var content = React.createElement(\"div\", {\n      onContextMenu: this.cancelContextMenu\n    }, this.state.menu);\n    var popoverClassName = classNames((_a = {}, _a[Classes.DARK] = this.state.isDarkTheme, _a));\n    // HACKHACK: workaround until we have access to Popper#scheduleUpdate().\n    // https://github.com/palantir/blueprint/issues/692\n    // Generate key based on offset so a new Popover instance is created\n    // when offset changes, to force recomputing position.\n    var key = this.state.offset === undefined ? \"\" : \"\".concat(this.state.offset.left, \"x\").concat(this.state.offset.top);\n    // wrap the popover in a positioned div to make sure it is properly\n    // offset on the screen.\n    /* eslint-disable deprecation/deprecation */\n    return React.createElement(\"div\", {\n      className: Classes.CONTEXT_MENU_POPOVER_TARGET,\n      style: this.state.offset\n    }, React.createElement(Popover, __assign({}, this.props, {\n      backdropProps: {\n        onContextMenu: this.handleBackdropContextMenu\n      },\n      content: content,\n      enforceFocus: false,\n      key: key,\n      hasBackdrop: true,\n      isOpen: this.state.isOpen,\n      minimal: true,\n      modifiers: POPPER_MODIFIERS,\n      onInteraction: this.handlePopoverInteraction,\n      position: Position.RIGHT_TOP,\n      popoverClassName: popoverClassName,\n      target: React.createElement(\"div\", null),\n      transitionDuration: TRANSITION_DURATION\n    })));\n    /* eslint-enable deprecation/deprecation */\n  };\n\n  ContextMenu.prototype.show = function (menu, offset, onClose, isDarkTheme) {\n    if (isDarkTheme === void 0) {\n      isDarkTheme = false;\n    }\n    this.setState({\n      isOpen: true,\n      menu: menu,\n      offset: offset,\n      onClose: onClose,\n      isDarkTheme: isDarkTheme\n    });\n  };\n  ContextMenu.prototype.hide = function () {\n    var _a, _b;\n    (_b = (_a = this.state).onClose) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.setState({\n      isOpen: false,\n      onClose: undefined\n    });\n  };\n  return ContextMenu;\n}(AbstractPureComponent2);\nvar contextMenuElement;\n// eslint-disable-next-line deprecation/deprecation\nvar contextMenu;\n/**\n * Show the given menu element at the given offset from the top-left corner of the viewport.\n * The menu will appear below-right of this point and will flip to below-left if there is not enough\n * room onscreen. The optional callback will be invoked when this menu closes.\n *\n * @deprecated use ContextMenu2\n */\nexport function show(menu, offset, onClose, isDarkTheme) {\n  if (contextMenuElement === undefined) {\n    contextMenuElement = document.createElement(\"div\");\n    contextMenuElement.classList.add(Classes.CONTEXT_MENU);\n    document.body.appendChild(contextMenuElement);\n    /* eslint-disable deprecation/deprecation */\n    contextMenu = ReactDOM.render(React.createElement(ContextMenu, {\n      onClosed: remove\n    }), contextMenuElement);\n    /* eslint-enable deprecation/deprecation */\n  }\n\n  contextMenu.show(menu, offset, onClose, isDarkTheme);\n}\n/** Hide the open context menu. */\nexport function hide() {\n  contextMenu === null || contextMenu === void 0 ? void 0 : contextMenu.hide();\n}\n/** Return whether a context menu is currently open. */\nexport function isOpen() {\n  return contextMenu != null && contextMenu.state.isOpen;\n}\nfunction remove() {\n  if (contextMenuElement != null) {\n    ReactDOM.unmountComponentAtNode(contextMenuElement);\n    contextMenuElement.remove();\n    contextMenuElement = undefined;\n    contextMenu = undefined;\n  }\n}","map":{"version":3,"mappings":"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","names":["classNames","React","ReactDOM","AbstractPureComponent2","Classes","Position","Popover","POPPER_MODIFIERS","preventOverflow","boundariesElement","TRANSITION_DURATION","__extends","_this","isDarkTheme","isOpen","e","preventDefault","persist","setTimeout","newTarget","document","elementFromPoint","clientX","clientY","newEventInit","dispatchEvent","MouseEvent","nextOpenState","requestAnimationFrame","hide","ContextMenu","content","onContextMenu","cancelContextMenu","state","menu","popoverClassName","_a","DARK","key","offset","undefined","left","top","className","CONTEXT_MENU_POPOVER_TARGET","style","props","backdropProps","handleBackdropContextMenu","enforceFocus","hasBackdrop","minimal","modifiers","onInteraction","handlePopoverInteraction","position","RIGHT_TOP","target","transitionDuration","onClose","setState","contextMenuElement","contextMenu","show","createElement","classList","add","CONTEXT_MENU","body","appendChild","render","onClosed","remove","unmountComponentAtNode"],"sources":["/Users/mansidabriwal/Documents/Web design class/React-Assignment/react-app/node_modules/@blueprintjs/core/src/components/context-menu/contextMenu.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview This component is DEPRECATED, and the code is frozen.\n * All changes & bugfixes should be made to ContextMenu2 instead.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport { AbstractPureComponent2, Classes, Position } from \"../../common\";\nimport { IOverlayLifecycleProps } from \"../overlay/overlay\";\nimport { Popover } from \"../popover/popover\";\nimport { PopperModifiers } from \"../popover/popoverSharedProps\";\n\nexport interface IOffset {\n    left: number;\n    top: number;\n}\n\ninterface IContextMenuState {\n    isOpen: boolean;\n    isDarkTheme: boolean;\n    menu?: JSX.Element;\n    offset?: IOffset;\n    onClose?: () => void;\n}\n\nconst POPPER_MODIFIERS: PopperModifiers = {\n    preventOverflow: { boundariesElement: \"viewport\" },\n};\nconst TRANSITION_DURATION = 100;\n\ntype IContextMenuProps = IOverlayLifecycleProps;\n\n/* istanbul ignore next */\n/** @deprecated use ContextMenu2 */\nclass ContextMenu extends AbstractPureComponent2<IContextMenuProps, IContextMenuState> {\n    public state: IContextMenuState = {\n        isDarkTheme: false,\n        isOpen: false,\n    };\n\n    public render() {\n        // prevent right-clicking in a context menu\n        const content = <div onContextMenu={this.cancelContextMenu}>{this.state.menu}</div>;\n        const popoverClassName = classNames({ [Classes.DARK]: this.state.isDarkTheme });\n\n        // HACKHACK: workaround until we have access to Popper#scheduleUpdate().\n        // https://github.com/palantir/blueprint/issues/692\n        // Generate key based on offset so a new Popover instance is created\n        // when offset changes, to force recomputing position.\n        const key = this.state.offset === undefined ? \"\" : `${this.state.offset.left}x${this.state.offset.top}`;\n\n        // wrap the popover in a positioned div to make sure it is properly\n        // offset on the screen.\n        /* eslint-disable deprecation/deprecation */\n        return (\n            <div className={Classes.CONTEXT_MENU_POPOVER_TARGET} style={this.state.offset}>\n                <Popover\n                    {...this.props}\n                    backdropProps={{ onContextMenu: this.handleBackdropContextMenu }}\n                    content={content}\n                    enforceFocus={false}\n                    key={key}\n                    hasBackdrop={true}\n                    isOpen={this.state.isOpen}\n                    minimal={true}\n                    modifiers={POPPER_MODIFIERS}\n                    onInteraction={this.handlePopoverInteraction}\n                    position={Position.RIGHT_TOP}\n                    popoverClassName={popoverClassName}\n                    target={<div />}\n                    transitionDuration={TRANSITION_DURATION}\n                />\n            </div>\n        );\n        /* eslint-enable deprecation/deprecation */\n    }\n\n    public show(menu: JSX.Element, offset: IOffset, onClose?: () => void, isDarkTheme = false) {\n        this.setState({ isOpen: true, menu, offset, onClose, isDarkTheme });\n    }\n\n    public hide() {\n        this.state.onClose?.();\n        this.setState({ isOpen: false, onClose: undefined });\n    }\n\n    private cancelContextMenu = (e: React.SyntheticEvent<HTMLDivElement>) => e.preventDefault();\n\n    private handleBackdropContextMenu = (e: React.MouseEvent<HTMLDivElement>) => {\n        // React function to remove from the event pool, useful when using a event within a callback\n        e.persist();\n        e.preventDefault();\n        // wait for backdrop to disappear so we can find the \"real\" element at event coordinates.\n        // timeout duration is equivalent to transition duration so we know it's animated out.\n        this.setTimeout(() => {\n            // retrigger context menu event at the element beneath the backdrop.\n            // if it has a `contextmenu` event handler then it'll be invoked.\n            // if it doesn't, no native menu will show (at least on OSX) :(\n            const newTarget = document.elementFromPoint(e.clientX, e.clientY);\n            const { view, ...newEventInit } = e;\n            newTarget?.dispatchEvent(new MouseEvent(\"contextmenu\", newEventInit));\n        }, TRANSITION_DURATION);\n    };\n\n    private handlePopoverInteraction = (nextOpenState: boolean) => {\n        if (!nextOpenState) {\n            // delay the actual hiding till the event queue clears\n            // to avoid flicker of opening twice\n            this.requestAnimationFrame(() => this.hide());\n        }\n    };\n}\n\nlet contextMenuElement: HTMLElement | undefined;\n// eslint-disable-next-line deprecation/deprecation\nlet contextMenu: ContextMenu | undefined;\n\n/**\n * Show the given menu element at the given offset from the top-left corner of the viewport.\n * The menu will appear below-right of this point and will flip to below-left if there is not enough\n * room onscreen. The optional callback will be invoked when this menu closes.\n *\n * @deprecated use ContextMenu2\n */\nexport function show(menu: JSX.Element, offset: IOffset, onClose?: () => void, isDarkTheme?: boolean) {\n    if (contextMenuElement === undefined) {\n        contextMenuElement = document.createElement(\"div\");\n        contextMenuElement.classList.add(Classes.CONTEXT_MENU);\n        document.body.appendChild(contextMenuElement);\n        /* eslint-disable deprecation/deprecation */\n        contextMenu = ReactDOM.render<IContextMenuProps>(\n            <ContextMenu onClosed={remove} />,\n            contextMenuElement,\n        ) as ContextMenu;\n        /* eslint-enable deprecation/deprecation */\n    }\n\n    contextMenu!.show(menu, offset, onClose, isDarkTheme);\n}\n\n/** Hide the open context menu. */\nexport function hide() {\n    contextMenu?.hide();\n}\n\n/** Return whether a context menu is currently open. */\nexport function isOpen() {\n    return contextMenu != null && contextMenu.state.isOpen;\n}\n\nfunction remove() {\n    if (contextMenuElement != null) {\n        ReactDOM.unmountComponentAtNode(contextMenuElement);\n        contextMenuElement.remove();\n        contextMenuElement = undefined;\n        contextMenu = undefined;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}