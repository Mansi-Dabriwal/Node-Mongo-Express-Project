{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends, __spreadArray } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, Keys, refHandler, setRef, Utils } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { getActiveElement } from \"../../common/utils\";\nimport { Icon, IconSize } from \"../icon/icon\";\nimport { Tag } from \"../tag/tag\";\n/** special value for absence of active tag */\nvar NONE = -1;\nvar TagInput = /** @class */function (_super) {\n  __extends(TagInput, _super);\n  function TagInput() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      activeIndex: NONE,\n      inputValue: _this.props.inputValue || \"\",\n      isInputFocused: false\n    };\n    _this.inputElement = null;\n    _this.handleRef = refHandler(_this, \"inputElement\", _this.props.inputRef);\n    _this.addTags = function (value, method) {\n      if (method === void 0) {\n        method = \"default\";\n      }\n      var _a = _this.props,\n        inputValue = _a.inputValue,\n        onAdd = _a.onAdd,\n        onChange = _a.onChange,\n        values = _a.values;\n      var newValues = _this.getValues(value);\n      var shouldClearInput = (onAdd === null || onAdd === void 0 ? void 0 : onAdd(newValues, method)) !== false && inputValue === undefined;\n      // avoid a potentially expensive computation if this prop is omitted\n      if (Utils.isFunction(onChange)) {\n        shouldClearInput = onChange(__spreadArray(__spreadArray([], values, true), newValues, true)) !== false && shouldClearInput;\n      }\n      // only explicit return false cancels text clearing\n      if (shouldClearInput) {\n        _this.setState({\n          inputValue: \"\"\n        });\n      }\n    };\n    _this.maybeRenderTag = function (tag, index) {\n      if (!tag) {\n        return null;\n      }\n      var _a = _this.props,\n        large = _a.large,\n        tagProps = _a.tagProps;\n      var props = Utils.isFunction(tagProps) ? tagProps(tag, index) : tagProps;\n      return React.createElement(Tag, __assign({\n        active: index === _this.state.activeIndex,\n        \"data-tag-index\": index,\n        key: tag + \"__\" + index,\n        large: large,\n        onRemove: _this.props.disabled ? undefined : _this.handleRemoveTag\n      }, props), tag);\n    };\n    _this.handleContainerClick = function () {\n      var _a;\n      (_a = _this.inputElement) === null || _a === void 0 ? void 0 : _a.focus();\n    };\n    _this.handleContainerBlur = function (_a) {\n      var currentTarget = _a.currentTarget;\n      _this.requestAnimationFrame(function () {\n        // we only care if the blur event is leaving the container.\n        // defer this check using rAF so activeElement will have updated.\n        var isFocusInsideContainer = currentTarget.contains(getActiveElement(_this.inputElement));\n        if (!isFocusInsideContainer) {\n          if (_this.props.addOnBlur && _this.state.inputValue !== undefined && _this.state.inputValue.length > 0) {\n            _this.addTags(_this.state.inputValue, \"blur\");\n          }\n          _this.setState({\n            activeIndex: NONE,\n            isInputFocused: false\n          });\n        }\n      });\n    };\n    _this.handleInputFocus = function (event) {\n      var _a, _b;\n      _this.setState({\n        isInputFocused: true\n      });\n      (_b = (_a = _this.props.inputProps) === null || _a === void 0 ? void 0 : _a.onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n    };\n    _this.handleInputChange = function (event) {\n      var _a, _b, _c, _d;\n      _this.setState({\n        activeIndex: NONE,\n        inputValue: event.currentTarget.value\n      });\n      (_b = (_a = _this.props).onInputChange) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n      (_d = (_c = _this.props.inputProps) === null || _c === void 0 ? void 0 : _c.onChange) === null || _d === void 0 ? void 0 : _d.call(_c, event);\n    };\n    _this.handleInputKeyDown = function (event) {\n      // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n      /* eslint-disable deprecation/deprecation */\n      var _a = event.currentTarget,\n        selectionEnd = _a.selectionEnd,\n        value = _a.value;\n      var activeIndex = _this.state.activeIndex;\n      var activeIndexToEmit = activeIndex;\n      if (event.which === Keys.ENTER && value.length > 0) {\n        _this.addTags(value, \"default\");\n      } else if (selectionEnd === 0 && _this.props.values.length > 0) {\n        // cursor at beginning of input allows interaction with tags.\n        // use selectionEnd to verify cursor position and no text selection.\n        if (event.which === Keys.ARROW_LEFT || event.which === Keys.ARROW_RIGHT) {\n          var nextActiveIndex = _this.getNextActiveIndex(event.which === Keys.ARROW_RIGHT ? 1 : -1);\n          if (nextActiveIndex !== activeIndex) {\n            event.stopPropagation();\n            activeIndexToEmit = nextActiveIndex;\n            _this.setState({\n              activeIndex: nextActiveIndex\n            });\n          }\n        } else if (event.which === Keys.BACKSPACE) {\n          _this.handleBackspaceToRemove(event);\n        } else if (event.which === Keys.DELETE) {\n          _this.handleDeleteToRemove(event);\n        }\n      }\n      _this.invokeKeyPressCallback(\"onKeyDown\", event, activeIndexToEmit);\n    };\n    _this.handleInputKeyUp = function (event) {\n      _this.invokeKeyPressCallback(\"onKeyUp\", event, _this.state.activeIndex);\n    };\n    _this.handleInputPaste = function (event) {\n      var separator = _this.props.separator;\n      var value = event.clipboardData.getData(\"text\");\n      if (!_this.props.addOnPaste || value.length === 0) {\n        return;\n      }\n      // special case as a UX nicety: if the user pasted only one value with no delimiters in it, leave that value in\n      // the input field so that the user can refine it before converting it to a tag manually.\n      if (separator === false || value.split(separator).length === 1) {\n        return;\n      }\n      event.preventDefault();\n      _this.addTags(value, \"paste\");\n    };\n    _this.handleRemoveTag = function (event) {\n      // using data attribute to simplify callback logic -- one handler for all children\n      var index = +event.currentTarget.parentElement.getAttribute(\"data-tag-index\");\n      _this.removeIndexFromValues(index);\n    };\n    return _this;\n  }\n  TagInput.getDerivedStateFromProps = function (props, state) {\n    if (props.inputValue !== state.prevInputValueProp) {\n      return {\n        inputValue: props.inputValue,\n        prevInputValueProp: props.inputValue\n      };\n    }\n    return null;\n  };\n  TagInput.prototype.render = function () {\n    var _a;\n    var _b = this.props,\n      className = _b.className,\n      disabled = _b.disabled,\n      fill = _b.fill,\n      inputProps = _b.inputProps,\n      intent = _b.intent,\n      large = _b.large,\n      leftIcon = _b.leftIcon,\n      placeholder = _b.placeholder,\n      values = _b.values;\n    var classes = classNames(Classes.INPUT, Classes.TAG_INPUT, (_a = {}, _a[Classes.ACTIVE] = this.state.isInputFocused, _a[Classes.DISABLED] = disabled, _a[Classes.FILL] = fill, _a[Classes.LARGE] = large, _a), Classes.intentClass(intent), className);\n    var isLarge = classes.indexOf(Classes.LARGE) > NONE;\n    // use placeholder prop only if it's defined and values list is empty or contains only falsy values\n    var isSomeValueDefined = values.some(function (val) {\n      return !!val;\n    });\n    var resolvedPlaceholder = placeholder == null || isSomeValueDefined ? inputProps === null || inputProps === void 0 ? void 0 : inputProps.placeholder : placeholder;\n    return React.createElement(\"div\", {\n      className: classes,\n      onBlur: this.handleContainerBlur,\n      onClick: this.handleContainerClick\n    }, React.createElement(Icon, {\n      className: Classes.TAG_INPUT_ICON,\n      icon: leftIcon,\n      size: isLarge ? IconSize.LARGE : IconSize.STANDARD\n    }), React.createElement(\"div\", {\n      className: Classes.TAG_INPUT_VALUES\n    }, values.map(this.maybeRenderTag), this.props.children, React.createElement(\"input\", __assign({\n      value: this.state.inputValue\n    }, inputProps, {\n      onFocus: this.handleInputFocus,\n      onChange: this.handleInputChange,\n      onKeyDown: this.handleInputKeyDown,\n      onKeyUp: this.handleInputKeyUp,\n      onPaste: this.handleInputPaste,\n      placeholder: resolvedPlaceholder,\n      ref: this.handleRef,\n      className: classNames(Classes.INPUT_GHOST, inputProps === null || inputProps === void 0 ? void 0 : inputProps.className),\n      disabled: disabled\n    }))), this.props.rightElement);\n  };\n  TagInput.prototype.componentDidUpdate = function (prevProps) {\n    if (prevProps.inputRef !== this.props.inputRef) {\n      setRef(prevProps.inputRef, null);\n      this.handleRef = refHandler(this, \"inputElement\", this.props.inputRef);\n      setRef(this.props.inputRef, this.inputElement);\n    }\n  };\n  TagInput.prototype.getNextActiveIndex = function (direction) {\n    var activeIndex = this.state.activeIndex;\n    if (activeIndex === NONE) {\n      // nothing active & moving left: select last defined value. otherwise select nothing.\n      return direction < 0 ? this.findNextIndex(this.props.values.length, -1) : NONE;\n    } else {\n      // otherwise, move in direction and clamp to bounds.\n      // note that upper bound allows going one beyond last item\n      // so focus can move off the right end, into the text input.\n      return this.findNextIndex(activeIndex, direction);\n    }\n  };\n  TagInput.prototype.findNextIndex = function (startIndex, direction) {\n    var values = this.props.values;\n    var index = startIndex + direction;\n    while (index > 0 && index < values.length && !values[index]) {\n      index += direction;\n    }\n    return Utils.clamp(index, 0, values.length);\n  };\n  /**\n   * Splits inputValue on separator prop,\n   * trims whitespace from each new value,\n   * and ignores empty values.\n   */\n  TagInput.prototype.getValues = function (inputValue) {\n    var separator = this.props.separator;\n    // NOTE: split() typings define two overrides for string and RegExp.\n    // this does not play well with our union prop type, so we'll just declare it as a valid type.\n    return (separator === false ? [inputValue] : inputValue.split(separator)).map(function (val) {\n      return val.trim();\n    }).filter(function (val) {\n      return val.length > 0;\n    });\n  };\n  TagInput.prototype.handleBackspaceToRemove = function (event) {\n    var previousActiveIndex = this.state.activeIndex;\n    // always move leftward one item (this will focus last item if nothing is focused)\n    this.setState({\n      activeIndex: this.getNextActiveIndex(-1)\n    });\n    // delete item if there was a previous valid selection (ignore first backspace to focus last item)\n    if (this.isValidIndex(previousActiveIndex)) {\n      event.stopPropagation();\n      this.removeIndexFromValues(previousActiveIndex);\n    }\n  };\n  TagInput.prototype.handleDeleteToRemove = function (event) {\n    var activeIndex = this.state.activeIndex;\n    if (this.isValidIndex(activeIndex)) {\n      event.stopPropagation();\n      this.removeIndexFromValues(activeIndex);\n    }\n  };\n  /** Remove the item at the given index by invoking `onRemove` and `onChange` accordingly. */\n  TagInput.prototype.removeIndexFromValues = function (index) {\n    var _a = this.props,\n      onChange = _a.onChange,\n      onRemove = _a.onRemove,\n      values = _a.values;\n    onRemove === null || onRemove === void 0 ? void 0 : onRemove(values[index], index);\n    onChange === null || onChange === void 0 ? void 0 : onChange(values.filter(function (_, i) {\n      return i !== index;\n    }));\n  };\n  TagInput.prototype.invokeKeyPressCallback = function (propCallbackName, event, activeIndex) {\n    var _a, _b, _c, _d;\n    (_b = (_a = this.props)[propCallbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, event, activeIndex === NONE ? undefined : activeIndex);\n    (_d = (_c = this.props.inputProps)[propCallbackName]) === null || _d === void 0 ? void 0 : _d.call(_c, event);\n  };\n  /** Returns whether the given index represents a valid item in `this.props.values`. */\n  TagInput.prototype.isValidIndex = function (index) {\n    return index !== NONE && index < this.props.values.length;\n  };\n  TagInput.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".TagInput\");\n  TagInput.defaultProps = {\n    addOnBlur: false,\n    addOnPaste: true,\n    inputProps: {},\n    separator: /[,\\n\\r]/,\n    tagProps: {}\n  };\n  return TagInput;\n}(AbstractPureComponent2);\nexport { TagInput };","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","Keys","refHandler","setRef","Utils","DISPLAYNAME_PREFIX","getActiveElement","Icon","IconSize","Tag","NONE","__extends","_this","activeIndex","inputValue","props","isInputFocused","inputRef","value","method","onAdd","onChange","values","newValues","getValues","shouldClearInput","undefined","isFunction","setState","tag","index","large","tagProps","active","state","key","onRemove","disabled","handleRemoveTag","inputElement","focus","_a","currentTarget","requestAnimationFrame","isFocusInsideContainer","contains","addOnBlur","length","addTags","event","inputProps","onFocus","onInputChange","selectionEnd","activeIndexToEmit","which","ENTER","ARROW_LEFT","ARROW_RIGHT","nextActiveIndex","getNextActiveIndex","stopPropagation","BACKSPACE","handleBackspaceToRemove","DELETE","handleDeleteToRemove","invokeKeyPressCallback","clipboardData","getData","addOnPaste","separator","split","preventDefault","parentElement","getAttribute","removeIndexFromValues","TagInput","prevInputValueProp","className","fill","intent","leftIcon","placeholder","classes","INPUT","TAG_INPUT","ACTIVE","DISABLED","FILL","LARGE","intentClass","isLarge","indexOf","isSomeValueDefined","some","val","resolvedPlaceholder","onBlur","handleContainerBlur","onClick","handleContainerClick","TAG_INPUT_ICON","icon","size","STANDARD","TAG_INPUT_VALUES","map","maybeRenderTag","children","handleInputFocus","handleInputChange","onKeyDown","handleInputKeyDown","onKeyUp","handleInputKeyUp","onPaste","handleInputPaste","ref","handleRef","INPUT_GHOST","rightElement","prevProps","direction","findNextIndex","startIndex","clamp","trim","filter","previousActiveIndex","isValidIndex","_","i","propCallbackName"],"sources":["/Users/mansidabriwal/Documents/Web design class/React-Assignment/react-app/node_modules/@blueprintjs/core/src/components/tag-input/tagInput.tsx"],"sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Keys, refHandler, setRef, Utils } from \"../../common\";\nimport { DISPLAYNAME_PREFIX, HTMLInputProps, IntentProps, MaybeElement, Props } from \"../../common/props\";\nimport { getActiveElement } from \"../../common/utils\";\nimport { Icon, IconName, IconSize } from \"../icon/icon\";\nimport { Tag, TagProps } from \"../tag/tag\";\n\n/**\n * The method in which a `TagInput` value was added.\n * - `\"default\"` - indicates that a value was added by manual selection.\n * - `\"blur\"` - indicates that a value was added when the `TagInput` lost focus.\n *   This is only possible when `addOnBlur=true`.\n * - `\"paste\"` - indicates that a value was added via paste. This is only\n *   possible when `addOnPaste=true`.\n */\nexport type TagInputAddMethod = \"default\" | \"blur\" | \"paste\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type TagInputProps = ITagInputProps;\n/** @deprecated use TagInputProps */\nexport interface ITagInputProps extends IntentProps, Props {\n    /**\n     * If true, `onAdd` will be invoked when the input loses focus.\n     * Otherwise, `onAdd` is only invoked when `enter` is pressed.\n     *\n     * @default false\n     */\n    addOnBlur?: boolean;\n\n    /**\n     * If true, `onAdd` will be invoked when the user pastes text containing the `separator`\n     * into the input. Otherwise, pasted text will remain in the input.\n     *\n     * __Note:__ For example, if `addOnPaste=true` and `separator=\"\\n\"` (new line), then:\n     * - Pasting `\"hello\"` will _not_ invoke `onAdd`\n     * - Pasting `\"hello\\n\"` will invoke `onAdd` with `[\"hello\"]`\n     * - Pasting `\"hello\\nworld\"` will invoke `onAdd` with `[\"hello\", \"world\"]`\n     *\n     * @default true\n     */\n    addOnPaste?: boolean;\n\n    children?: React.ReactNode;\n\n    /**\n     * Whether the component is non-interactive.\n     * Note that you'll also need to disable the component's `rightElement`,\n     * if appropriate.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /** Whether the tag input should take up the full width of its container. */\n    fill?: boolean;\n\n    /**\n     * React props to pass to the `<input>` element.\n     * Note that `ref` and `key` are not supported here; use `inputRef` below.\n     */\n    inputProps?: HTMLInputProps;\n\n    /** Ref handler for the `<input>` element. */\n    inputRef?: React.Ref<HTMLInputElement>;\n\n    /** Controlled value of the `<input>` element. This is shorthand for `inputProps={{ value }}`. */\n    inputValue?: string;\n\n    /** Whether the tag input should use a large size. */\n    large?: boolean;\n\n    /** Name of a Blueprint UI icon (or an icon element) to render on the left side of the input. */\n    leftIcon?: IconName | MaybeElement;\n\n    /**\n     * Callback invoked when new tags are added by the user pressing `enter` on the input.\n     * Receives the current value of the input field split by `separator` into an array.\n     * New tags are expected to be appended to the list.\n     *\n     * The input will be cleared after `onAdd` is invoked _unless_ the callback explicitly\n     * returns `false`. This is useful if the provided `value` is somehow invalid and should\n     * not be added as a tag.\n     */\n    onAdd?: (values: string[], method: TagInputAddMethod) => boolean | void;\n\n    /**\n     * Callback invoked when new tags are added or removed. Receives the updated list of `values`:\n     * new tags are appended to the end of the list, removed tags are removed at their index.\n     *\n     * Like `onAdd`, the input will be cleared after this handler is invoked _unless_ the callback\n     * explicitly returns `false`.\n     *\n     * This callback essentially implements basic `onAdd` and `onRemove` functionality and merges\n     * the two handlers into one to simplify controlled usage.\n     * ```\n     */\n    onChange?: (values: React.ReactNode[]) => boolean | void;\n\n    /**\n     * Callback invoked when the value of `<input>` element is changed.\n     * This is shorthand for `inputProps={{ onChange }}`.\n     */\n    onInputChange?: React.FormEventHandler<HTMLInputElement>;\n\n    /**\n     * Callback invoked when the user depresses a keyboard key.\n     * Receives the event and the index of the active tag (or `undefined` if\n     * focused in the input).\n     */\n    onKeyDown?: (event: React.KeyboardEvent<HTMLElement>, index?: number) => void;\n\n    /**\n     * Callback invoked when the user releases a keyboard key.\n     * Receives the event and the index of the active tag (or `undefined` if\n     * focused in the input).\n     */\n    onKeyUp?: (event: React.KeyboardEvent<HTMLElement>, index?: number) => void;\n\n    /**\n     * Callback invoked when the user clicks the X button on a tag.\n     * Receives value and index of removed tag.\n     */\n    onRemove?: (value: React.ReactNode, index: number) => void;\n\n    /**\n     * Input placeholder text which will not appear if `values` contains any items\n     * (consistent with default HTML input behavior).\n     * Use `inputProps.placeholder` if you want the placeholder text to _always_ appear.\n     *\n     * If you define both `placeholder` and `inputProps.placeholder`, then the former will appear\n     * when `values` is empty and the latter at all other times.\n     */\n    placeholder?: string;\n\n    /**\n     * Element to render on right side of input.\n     * For best results, use a small spinner or minimal button (button height will adjust if `TagInput` uses large styles).\n     * Other elements will likely require custom styles for correct positioning.\n     */\n    rightElement?: JSX.Element;\n\n    /**\n     * Separator pattern used to split input text into multiple values. Default value splits on commas and newlines.\n     * Explicit `false` value disables splitting (note that `onAdd` will still receive an array of length 1).\n     *\n     * @default /[,\\n\\r]/\n     */\n    separator?: string | RegExp | false;\n\n    /**\n     * React props to pass to each `Tag`. Provide an object to pass the same props to every tag,\n     * or a function to customize props per tag.\n     *\n     * If you define `onRemove` here then you will have to implement your own tag removal\n     * handling as `TagInput`'s own `onRemove` handler will never be invoked.\n     */\n    tagProps?: TagProps | ((value: React.ReactNode, index: number) => TagProps);\n\n    /**\n     * Controlled tag values. Each value will be rendered inside a `Tag`, which can be customized\n     * using `tagProps`. Therefore, any valid React node can be used as a `TagInput` value; falsy\n     * values will not be rendered.\n     */\n    values: readonly React.ReactNode[];\n}\n\nexport interface ITagInputState {\n    activeIndex: number;\n    inputValue: string;\n    isInputFocused: boolean;\n    prevInputValueProp?: string;\n}\n\n/** special value for absence of active tag */\nconst NONE = -1;\n\nexport class TagInput extends AbstractPureComponent2<TagInputProps, ITagInputState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.TagInput`;\n\n    public static defaultProps: Partial<TagInputProps> = {\n        addOnBlur: false,\n        addOnPaste: true,\n        inputProps: {},\n        separator: /[,\\n\\r]/,\n        tagProps: {},\n    };\n\n    public static getDerivedStateFromProps(\n        props: Readonly<TagInputProps>,\n        state: Readonly<ITagInputState>,\n    ): Partial<ITagInputState> | null {\n        if (props.inputValue !== state.prevInputValueProp) {\n            return {\n                inputValue: props.inputValue,\n                prevInputValueProp: props.inputValue,\n            };\n        }\n        return null;\n    }\n\n    public state: ITagInputState = {\n        activeIndex: NONE,\n        inputValue: this.props.inputValue || \"\",\n        isInputFocused: false,\n    };\n\n    public inputElement: HTMLInputElement | null = null;\n\n    private handleRef: React.Ref<HTMLInputElement> = refHandler(this, \"inputElement\", this.props.inputRef);\n\n    public render() {\n        const { className, disabled, fill, inputProps, intent, large, leftIcon, placeholder, values } = this.props;\n\n        const classes = classNames(\n            Classes.INPUT,\n            Classes.TAG_INPUT,\n            {\n                [Classes.ACTIVE]: this.state.isInputFocused,\n                [Classes.DISABLED]: disabled,\n                [Classes.FILL]: fill,\n                [Classes.LARGE]: large,\n            },\n            Classes.intentClass(intent),\n            className,\n        );\n        const isLarge = classes.indexOf(Classes.LARGE) > NONE;\n\n        // use placeholder prop only if it's defined and values list is empty or contains only falsy values\n        const isSomeValueDefined = values.some(val => !!val);\n        const resolvedPlaceholder = placeholder == null || isSomeValueDefined ? inputProps?.placeholder : placeholder;\n\n        return (\n            <div className={classes} onBlur={this.handleContainerBlur} onClick={this.handleContainerClick}>\n                <Icon\n                    className={Classes.TAG_INPUT_ICON}\n                    icon={leftIcon}\n                    size={isLarge ? IconSize.LARGE : IconSize.STANDARD}\n                />\n                <div className={Classes.TAG_INPUT_VALUES}>\n                    {values.map(this.maybeRenderTag)}\n                    {this.props.children}\n                    <input\n                        value={this.state.inputValue}\n                        {...inputProps}\n                        onFocus={this.handleInputFocus}\n                        onChange={this.handleInputChange}\n                        onKeyDown={this.handleInputKeyDown}\n                        onKeyUp={this.handleInputKeyUp}\n                        onPaste={this.handleInputPaste}\n                        placeholder={resolvedPlaceholder}\n                        ref={this.handleRef}\n                        className={classNames(Classes.INPUT_GHOST, inputProps?.className)}\n                        disabled={disabled}\n                    />\n                </div>\n                {this.props.rightElement}\n            </div>\n        );\n    }\n\n    public componentDidUpdate(prevProps: TagInputProps) {\n        if (prevProps.inputRef !== this.props.inputRef) {\n            setRef(prevProps.inputRef, null);\n            this.handleRef = refHandler(this, \"inputElement\", this.props.inputRef);\n            setRef(this.props.inputRef, this.inputElement);\n        }\n    }\n\n    private addTags = (value: string, method: TagInputAddMethod = \"default\") => {\n        const { inputValue, onAdd, onChange, values } = this.props;\n        const newValues = this.getValues(value);\n        let shouldClearInput = onAdd?.(newValues, method) !== false && inputValue === undefined;\n        // avoid a potentially expensive computation if this prop is omitted\n        if (Utils.isFunction(onChange)) {\n            shouldClearInput = onChange([...values, ...newValues]) !== false && shouldClearInput;\n        }\n        // only explicit return false cancels text clearing\n        if (shouldClearInput) {\n            this.setState({ inputValue: \"\" });\n        }\n    };\n\n    private maybeRenderTag = (tag: React.ReactNode, index: number) => {\n        if (!tag) {\n            return null;\n        }\n        const { large, tagProps } = this.props;\n        const props = Utils.isFunction(tagProps) ? tagProps(tag, index) : tagProps;\n        return (\n            <Tag\n                active={index === this.state.activeIndex}\n                data-tag-index={index}\n                key={tag + \"__\" + index}\n                large={large}\n                onRemove={this.props.disabled ? undefined : this.handleRemoveTag}\n                {...props}\n            >\n                {tag}\n            </Tag>\n        );\n    };\n\n    private getNextActiveIndex(direction: number) {\n        const { activeIndex } = this.state;\n        if (activeIndex === NONE) {\n            // nothing active & moving left: select last defined value. otherwise select nothing.\n            return direction < 0 ? this.findNextIndex(this.props.values.length, -1) : NONE;\n        } else {\n            // otherwise, move in direction and clamp to bounds.\n            // note that upper bound allows going one beyond last item\n            // so focus can move off the right end, into the text input.\n            return this.findNextIndex(activeIndex, direction);\n        }\n    }\n\n    private findNextIndex(startIndex: number, direction: number) {\n        const { values } = this.props;\n        let index = startIndex + direction;\n        while (index > 0 && index < values.length && !values[index]) {\n            index += direction;\n        }\n        return Utils.clamp(index, 0, values.length);\n    }\n\n    /**\n     * Splits inputValue on separator prop,\n     * trims whitespace from each new value,\n     * and ignores empty values.\n     */\n    private getValues(inputValue: string) {\n        const { separator } = this.props;\n        // NOTE: split() typings define two overrides for string and RegExp.\n        // this does not play well with our union prop type, so we'll just declare it as a valid type.\n        return (separator === false ? [inputValue] : inputValue.split(separator as string))\n            .map(val => val.trim())\n            .filter(val => val.length > 0);\n    }\n\n    private handleContainerClick = () => {\n        this.inputElement?.focus();\n    };\n\n    private handleContainerBlur = ({ currentTarget }: React.FocusEvent<HTMLDivElement>) => {\n        this.requestAnimationFrame(() => {\n            // we only care if the blur event is leaving the container.\n            // defer this check using rAF so activeElement will have updated.\n            const isFocusInsideContainer = currentTarget.contains(getActiveElement(this.inputElement));\n            if (!isFocusInsideContainer) {\n                if (this.props.addOnBlur && this.state.inputValue !== undefined && this.state.inputValue.length > 0) {\n                    this.addTags(this.state.inputValue, \"blur\");\n                }\n                this.setState({ activeIndex: NONE, isInputFocused: false });\n            }\n        });\n    };\n\n    private handleInputFocus = (event: React.FocusEvent<HTMLInputElement>) => {\n        this.setState({ isInputFocused: true });\n        this.props.inputProps?.onFocus?.(event);\n    };\n\n    private handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        this.setState({ activeIndex: NONE, inputValue: event.currentTarget.value });\n        this.props.onInputChange?.(event);\n        this.props.inputProps?.onChange?.(event);\n    };\n\n    private handleInputKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {\n        // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        /* eslint-disable deprecation/deprecation */\n\n        const { selectionEnd, value } = event.currentTarget;\n        const { activeIndex } = this.state;\n\n        let activeIndexToEmit = activeIndex;\n\n        if (event.which === Keys.ENTER && value.length > 0) {\n            this.addTags(value, \"default\");\n        } else if (selectionEnd === 0 && this.props.values.length > 0) {\n            // cursor at beginning of input allows interaction with tags.\n            // use selectionEnd to verify cursor position and no text selection.\n            if (event.which === Keys.ARROW_LEFT || event.which === Keys.ARROW_RIGHT) {\n                const nextActiveIndex = this.getNextActiveIndex(event.which === Keys.ARROW_RIGHT ? 1 : -1);\n                if (nextActiveIndex !== activeIndex) {\n                    event.stopPropagation();\n                    activeIndexToEmit = nextActiveIndex;\n                    this.setState({ activeIndex: nextActiveIndex });\n                }\n            } else if (event.which === Keys.BACKSPACE) {\n                this.handleBackspaceToRemove(event);\n            } else if (event.which === Keys.DELETE) {\n                this.handleDeleteToRemove(event);\n            }\n        }\n\n        this.invokeKeyPressCallback(\"onKeyDown\", event, activeIndexToEmit);\n    };\n\n    private handleInputKeyUp = (event: React.KeyboardEvent<HTMLInputElement>) => {\n        this.invokeKeyPressCallback(\"onKeyUp\", event, this.state.activeIndex);\n    };\n\n    private handleInputPaste = (event: React.ClipboardEvent<HTMLInputElement>) => {\n        const { separator } = this.props;\n        const value = event.clipboardData.getData(\"text\");\n\n        if (!this.props.addOnPaste || value.length === 0) {\n            return;\n        }\n\n        // special case as a UX nicety: if the user pasted only one value with no delimiters in it, leave that value in\n        // the input field so that the user can refine it before converting it to a tag manually.\n        if (separator === false || value.split(separator!).length === 1) {\n            return;\n        }\n\n        event.preventDefault();\n        this.addTags(value, \"paste\");\n    };\n\n    private handleRemoveTag = (event: React.MouseEvent<HTMLSpanElement>) => {\n        // using data attribute to simplify callback logic -- one handler for all children\n        const index = +event.currentTarget.parentElement!.getAttribute(\"data-tag-index\")!;\n        this.removeIndexFromValues(index);\n    };\n\n    private handleBackspaceToRemove(event: React.KeyboardEvent<HTMLInputElement>) {\n        const previousActiveIndex = this.state.activeIndex;\n        // always move leftward one item (this will focus last item if nothing is focused)\n        this.setState({ activeIndex: this.getNextActiveIndex(-1) });\n        // delete item if there was a previous valid selection (ignore first backspace to focus last item)\n        if (this.isValidIndex(previousActiveIndex)) {\n            event.stopPropagation();\n            this.removeIndexFromValues(previousActiveIndex);\n        }\n    }\n\n    private handleDeleteToRemove(event: React.KeyboardEvent<HTMLInputElement>) {\n        const { activeIndex } = this.state;\n        if (this.isValidIndex(activeIndex)) {\n            event.stopPropagation();\n            this.removeIndexFromValues(activeIndex);\n        }\n    }\n\n    /** Remove the item at the given index by invoking `onRemove` and `onChange` accordingly. */\n    private removeIndexFromValues(index: number) {\n        const { onChange, onRemove, values } = this.props;\n        onRemove?.(values[index], index);\n        onChange?.(values.filter((_, i) => i !== index));\n    }\n\n    private invokeKeyPressCallback(\n        propCallbackName: \"onKeyDown\" | \"onKeyUp\",\n        event: React.KeyboardEvent<HTMLInputElement>,\n        activeIndex: number,\n    ) {\n        this.props[propCallbackName]?.(event, activeIndex === NONE ? undefined : activeIndex);\n        this.props.inputProps![propCallbackName]?.(event);\n    }\n\n    /** Returns whether the given index represents a valid item in `this.props.values`. */\n    private isValidIndex(index: number) {\n        return index !== NONE && index < this.props.values.length;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}