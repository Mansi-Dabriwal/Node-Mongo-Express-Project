{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { formatPercentage } from \"./sliderUtils\";\n// props that require number values, for validation\nvar NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"];\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\nvar Handle = /** @class */function (_super) {\n  __extends(Handle, _super);\n  function Handle() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      isMoving: false\n    };\n    _this.handleElement = null;\n    _this.refHandlers = {\n      handle: function (el) {\n        return _this.handleElement = el;\n      }\n    };\n    _this.beginHandleMovement = function (event) {\n      document.addEventListener(\"mousemove\", _this.handleHandleMovement);\n      document.addEventListener(\"mouseup\", _this.endHandleMovement);\n      _this.setState({\n        isMoving: true\n      });\n      _this.changeValue(_this.clientToValue(_this.mouseEventClientOffset(event)));\n    };\n    _this.beginHandleTouchMovement = function (event) {\n      document.addEventListener(\"touchmove\", _this.handleHandleTouchMovement);\n      document.addEventListener(\"touchend\", _this.endHandleTouchMovement);\n      document.addEventListener(\"touchcancel\", _this.endHandleTouchMovement);\n      _this.setState({\n        isMoving: true\n      });\n      _this.changeValue(_this.clientToValue(_this.touchEventClientOffset(event)));\n    };\n    _this.getStyleProperties = function () {\n      if (_this.handleElement == null) {\n        return {};\n      }\n      // The handle midpoint of RangeSlider is actually shifted by a margin to\n      // be on the edge of the visible handle element. Because the midpoint\n      // calculation does not take this margin into account, we instead\n      // measure the long side (which is equal to the short side plus the\n      // margin).\n      var _a = _this.props,\n        _b = _a.min,\n        min = _b === void 0 ? 0 : _b,\n        tickSizeRatio = _a.tickSizeRatio,\n        value = _a.value,\n        vertical = _a.vertical;\n      var handleMidpoint = _this.getHandleMidpointAndOffset(_this.handleElement, true).handleMidpoint;\n      var offsetRatio = (value - min) * tickSizeRatio;\n      var offsetCalc = \"calc(\".concat(formatPercentage(offsetRatio), \" - \").concat(handleMidpoint, \"px)\");\n      return vertical ? {\n        bottom: offsetCalc\n      } : {\n        left: offsetCalc\n      };\n    };\n    _this.endHandleMovement = function (event) {\n      _this.handleMoveEndedAt(_this.mouseEventClientOffset(event));\n    };\n    _this.endHandleTouchMovement = function (event) {\n      _this.handleMoveEndedAt(_this.touchEventClientOffset(event));\n    };\n    _this.handleMoveEndedAt = function (clientPixel) {\n      var _a, _b;\n      _this.removeDocumentEventListeners();\n      _this.setState({\n        isMoving: false\n      });\n      // always invoke onRelease; changeValue may call onChange if value is different\n      var finalValue = _this.changeValue(_this.clientToValue(clientPixel));\n      (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, finalValue);\n    };\n    _this.handleHandleMovement = function (event) {\n      _this.handleMovedTo(_this.mouseEventClientOffset(event));\n    };\n    _this.handleHandleTouchMovement = function (event) {\n      _this.handleMovedTo(_this.touchEventClientOffset(event));\n    };\n    _this.handleMovedTo = function (clientPixel) {\n      if (_this.state.isMoving && !_this.props.disabled) {\n        _this.changeValue(_this.clientToValue(clientPixel));\n      }\n    };\n    _this.handleKeyDown = function (event) {\n      var _a = _this.props,\n        stepSize = _a.stepSize,\n        value = _a.value;\n      // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n      /* eslint-disable-next-line deprecation/deprecation */\n      var which = event.which;\n      if (which === Keys.ARROW_DOWN || which === Keys.ARROW_LEFT) {\n        _this.changeValue(value - stepSize);\n        // this key event has been handled! prevent browser scroll on up/down\n        event.preventDefault();\n      } else if (which === Keys.ARROW_UP || which === Keys.ARROW_RIGHT) {\n        _this.changeValue(value + stepSize);\n        event.preventDefault();\n      }\n    };\n    _this.handleKeyUp = function (event) {\n      var _a, _b;\n      // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n      /* eslint-disable-next-line deprecation/deprecation */\n      if ([Keys.ARROW_UP, Keys.ARROW_DOWN, Keys.ARROW_LEFT, Keys.ARROW_RIGHT].indexOf(event.which) >= 0) {\n        (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.value);\n      }\n    };\n    return _this;\n  }\n  Handle.prototype.componentDidMount = function () {\n    // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n    // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n    this.forceUpdate();\n  };\n  Handle.prototype.render = function () {\n    var _a;\n    var _b = this.props,\n      className = _b.className,\n      disabled = _b.disabled,\n      label = _b.label,\n      min = _b.min,\n      max = _b.max,\n      value = _b.value,\n      vertical = _b.vertical,\n      htmlProps = _b.htmlProps;\n    var isMoving = this.state.isMoving;\n    return React.createElement(\"span\", __assign({\n      role: \"slider\",\n      tabIndex: 0\n    }, htmlProps, {\n      className: classNames(Classes.SLIDER_HANDLE, (_a = {}, _a[Classes.ACTIVE] = isMoving, _a), className),\n      onKeyDown: disabled ? undefined : this.handleKeyDown,\n      onKeyUp: disabled ? undefined : this.handleKeyUp,\n      onMouseDown: disabled ? undefined : this.beginHandleMovement,\n      onTouchStart: disabled ? undefined : this.beginHandleTouchMovement,\n      ref: this.refHandlers.handle,\n      style: this.getStyleProperties(),\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": vertical ? \"vertical\" : \"horizontal\"\n    }), label == null ? null : React.createElement(\"span\", {\n      className: Classes.SLIDER_LABEL\n    }, label));\n  };\n  Handle.prototype.componentWillUnmount = function () {\n    this.removeDocumentEventListeners();\n  };\n  /** Convert client pixel to value between min and max. */\n  Handle.prototype.clientToValue = function (clientPixel) {\n    var _a = this.props,\n      stepSize = _a.stepSize,\n      tickSize = _a.tickSize,\n      value = _a.value,\n      vertical = _a.vertical;\n    if (this.handleElement == null) {\n      return value;\n    }\n    // #1769: this logic doesn't work perfectly when the tick size is\n    // smaller than the handle size; it may be off by a tick or two.\n    var clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n    var handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n    var pixelDelta = clientPixelNormalized - handleCenterPixel;\n    if (isNaN(pixelDelta)) {\n      return value;\n    }\n    // convert pixels to range value in increments of `stepSize`\n    return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n  };\n  Handle.prototype.mouseEventClientOffset = function (event) {\n    return this.props.vertical ? event.clientY : event.clientX;\n  };\n  Handle.prototype.touchEventClientOffset = function (event) {\n    var touch = event.changedTouches[0];\n    return this.props.vertical ? touch.clientY : touch.clientX;\n  };\n  Handle.prototype.validateProps = function (props) {\n    for (var _i = 0, NUMBER_PROPS_1 = NUMBER_PROPS; _i < NUMBER_PROPS_1.length; _i++) {\n      var prop = NUMBER_PROPS_1[_i];\n      if (typeof props[prop] !== \"number\") {\n        throw new Error(\"[Blueprint] <Handle> requires number value for \".concat(prop, \" prop\"));\n      }\n    }\n  };\n  /** Clamp value and invoke callback if it differs from current value */\n  Handle.prototype.changeValue = function (newValue, callback) {\n    if (callback === void 0) {\n      callback = this.props.onChange;\n    }\n    newValue = this.clamp(newValue);\n    if (!isNaN(newValue) && this.props.value !== newValue) {\n      callback === null || callback === void 0 ? void 0 : callback(newValue);\n    }\n    return newValue;\n  };\n  /** Clamp value between min and max props */\n  Handle.prototype.clamp = function (value) {\n    return clamp(value, this.props.min, this.props.max);\n  };\n  Handle.prototype.getHandleElementCenterPixel = function (handleElement) {\n    var _a = this.getHandleMidpointAndOffset(handleElement),\n      handleMidpoint = _a.handleMidpoint,\n      handleOffset = _a.handleOffset;\n    return handleOffset + handleMidpoint;\n  };\n  Handle.prototype.getHandleMidpointAndOffset = function (handleElement, useOppositeDimension) {\n    if (useOppositeDimension === void 0) {\n      useOppositeDimension = false;\n    }\n    if (handleElement == null) {\n      return {\n        handleMidpoint: 0,\n        handleOffset: 0\n      };\n    }\n    var vertical = this.props.vertical;\n    // getBoundingClientRect().height includes border size; clientHeight does not.\n    var handleRect = handleElement.getBoundingClientRect();\n    var sizeKey = vertical ? useOppositeDimension ? \"width\" : \"height\" : useOppositeDimension ? \"height\" : \"width\";\n    // \"bottom\" value seems to be consistently incorrect, so explicitly\n    // calculate it using the window offset instead.\n    var handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n    return {\n      handleMidpoint: handleRect[sizeKey] / 2,\n      handleOffset: handleOffset\n    };\n  };\n  Handle.prototype.removeDocumentEventListeners = function () {\n    document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n    document.removeEventListener(\"mouseup\", this.endHandleMovement);\n    document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n    document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n    document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n  };\n  Handle.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".SliderHandle\");\n  return Handle;\n}(AbstractPureComponent2);\nexport { Handle };","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","Keys","DISPLAYNAME_PREFIX","clamp","formatPercentage","NUMBER_PROPS","__extends","_this","isMoving","handle","el","handleElement","event","document","addEventListener","handleHandleMovement","endHandleMovement","setState","changeValue","clientToValue","mouseEventClientOffset","handleHandleTouchMovement","endHandleTouchMovement","touchEventClientOffset","props","_b","min","tickSizeRatio","value","vertical","getHandleMidpointAndOffset","offsetRatio","offsetCalc","handleMidpoint","bottom","left","handleMoveEndedAt","clientPixel","removeDocumentEventListeners","finalValue","onRelease","handleMovedTo","state","disabled","stepSize","which","ARROW_DOWN","ARROW_LEFT","preventDefault","ARROW_UP","ARROW_RIGHT","indexOf","Handle","forceUpdate","className","label","max","htmlProps","role","tabIndex","SLIDER_HANDLE","_a","ACTIVE","onKeyDown","undefined","handleKeyDown","onKeyUp","handleKeyUp","onMouseDown","beginHandleMovement","onTouchStart","beginHandleTouchMovement","ref","refHandlers","style","getStyleProperties","SLIDER_LABEL","tickSize","clientPixelNormalized","window","innerHeight","handleCenterPixel","getHandleElementCenterPixel","pixelDelta","isNaN","Math","round","clientY","clientX","touch","changedTouches","NUMBER_PROPS_1","_i","prop","Error","newValue","callback","onChange","handleOffset","useOppositeDimension","handleRect","getBoundingClientRect","sizeKey","top","removeEventListener"],"sources":["/Users/mansidabriwal/Documents/Web design class/React-Assignment/react-app/node_modules/@blueprintjs/core/src/components/slider/handle.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { HandleProps } from \"./handleProps\";\nimport { formatPercentage } from \"./sliderUtils\";\n\n/**\n * Props for the internal <Handle> component needs some additional info from the parent Slider.\n */\nexport interface IInternalHandleProps extends HandleProps {\n    disabled?: boolean;\n    label: JSX.Element | string | undefined;\n    max: number;\n    min: number;\n    stepSize: number;\n    tickSize: number;\n    tickSizeRatio: number;\n    vertical: boolean;\n}\n\nexport interface IHandleState {\n    /** whether slider handle is currently being dragged */\n    isMoving?: boolean;\n}\n\n// props that require number values, for validation\nconst NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"];\n\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\n\nexport class Handle extends AbstractPureComponent2<IInternalHandleProps, IHandleState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.SliderHandle`;\n\n    public state = {\n        isMoving: false,\n    };\n\n    private handleElement: HTMLElement | null = null;\n\n    private refHandlers = {\n        handle: (el: HTMLSpanElement) => (this.handleElement = el),\n    };\n\n    public componentDidMount() {\n        // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n        // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n        this.forceUpdate();\n    }\n\n    public render() {\n        const { className, disabled, label, min, max, value, vertical, htmlProps } = this.props;\n        const { isMoving } = this.state;\n\n        return (\n            <span\n                role=\"slider\"\n                tabIndex={0}\n                {...htmlProps}\n                className={classNames(Classes.SLIDER_HANDLE, { [Classes.ACTIVE]: isMoving }, className)}\n                onKeyDown={disabled ? undefined : this.handleKeyDown}\n                onKeyUp={disabled ? undefined : this.handleKeyUp}\n                onMouseDown={disabled ? undefined : this.beginHandleMovement}\n                onTouchStart={disabled ? undefined : this.beginHandleTouchMovement}\n                ref={this.refHandlers.handle}\n                style={this.getStyleProperties()}\n                aria-valuemin={min}\n                aria-valuemax={max}\n                aria-valuenow={value}\n                aria-orientation={vertical ? \"vertical\" : \"horizontal\"}\n            >\n                {label == null ? null : <span className={Classes.SLIDER_LABEL}>{label}</span>}\n            </span>\n        );\n    }\n\n    public componentWillUnmount() {\n        this.removeDocumentEventListeners();\n    }\n\n    /** Convert client pixel to value between min and max. */\n    public clientToValue(clientPixel: number) {\n        const { stepSize, tickSize, value, vertical } = this.props;\n        if (this.handleElement == null) {\n            return value;\n        }\n\n        // #1769: this logic doesn't work perfectly when the tick size is\n        // smaller than the handle size; it may be off by a tick or two.\n        const clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n        const handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n        const pixelDelta = clientPixelNormalized - handleCenterPixel;\n\n        if (isNaN(pixelDelta)) {\n            return value;\n        }\n        // convert pixels to range value in increments of `stepSize`\n        return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n    }\n\n    public mouseEventClientOffset(event: MouseEvent | React.MouseEvent<HTMLElement>) {\n        return this.props.vertical ? event.clientY : event.clientX;\n    }\n\n    public touchEventClientOffset(event: TouchEvent | React.TouchEvent<HTMLElement>) {\n        const touch = event.changedTouches[0];\n        return this.props.vertical ? touch.clientY : touch.clientX;\n    }\n\n    public beginHandleMovement = (event: MouseEvent | React.MouseEvent<HTMLElement>) => {\n        document.addEventListener(\"mousemove\", this.handleHandleMovement);\n        document.addEventListener(\"mouseup\", this.endHandleMovement);\n        this.setState({ isMoving: true });\n        this.changeValue(this.clientToValue(this.mouseEventClientOffset(event)));\n    };\n\n    public beginHandleTouchMovement = (event: TouchEvent | React.TouchEvent<HTMLElement>) => {\n        document.addEventListener(\"touchmove\", this.handleHandleTouchMovement);\n        document.addEventListener(\"touchend\", this.endHandleTouchMovement);\n        document.addEventListener(\"touchcancel\", this.endHandleTouchMovement);\n        this.setState({ isMoving: true });\n        this.changeValue(this.clientToValue(this.touchEventClientOffset(event)));\n    };\n\n    protected validateProps(props: IInternalHandleProps) {\n        for (const prop of NUMBER_PROPS) {\n            if (typeof (props as any)[prop] !== \"number\") {\n                throw new Error(`[Blueprint] <Handle> requires number value for ${prop} prop`);\n            }\n        }\n    }\n\n    private getStyleProperties = (): React.CSSProperties => {\n        if (this.handleElement == null) {\n            return {};\n        }\n\n        // The handle midpoint of RangeSlider is actually shifted by a margin to\n        // be on the edge of the visible handle element. Because the midpoint\n        // calculation does not take this margin into account, we instead\n        // measure the long side (which is equal to the short side plus the\n        // margin).\n\n        const { min = 0, tickSizeRatio, value, vertical } = this.props;\n        const { handleMidpoint } = this.getHandleMidpointAndOffset(this.handleElement, true);\n        const offsetRatio = (value - min) * tickSizeRatio;\n        const offsetCalc = `calc(${formatPercentage(offsetRatio)} - ${handleMidpoint}px)`;\n        return vertical ? { bottom: offsetCalc } : { left: offsetCalc };\n    };\n\n    private endHandleMovement = (event: MouseEvent) => {\n        this.handleMoveEndedAt(this.mouseEventClientOffset(event));\n    };\n\n    private endHandleTouchMovement = (event: TouchEvent) => {\n        this.handleMoveEndedAt(this.touchEventClientOffset(event));\n    };\n\n    private handleMoveEndedAt = (clientPixel: number) => {\n        this.removeDocumentEventListeners();\n        this.setState({ isMoving: false });\n        // always invoke onRelease; changeValue may call onChange if value is different\n        const finalValue = this.changeValue(this.clientToValue(clientPixel));\n        this.props.onRelease?.(finalValue);\n    };\n\n    private handleHandleMovement = (event: MouseEvent) => {\n        this.handleMovedTo(this.mouseEventClientOffset(event));\n    };\n\n    private handleHandleTouchMovement = (event: TouchEvent) => {\n        this.handleMovedTo(this.touchEventClientOffset(event));\n    };\n\n    private handleMovedTo = (clientPixel: number) => {\n        if (this.state.isMoving && !this.props.disabled) {\n            this.changeValue(this.clientToValue(clientPixel));\n        }\n    };\n\n    private handleKeyDown = (event: React.KeyboardEvent<HTMLSpanElement>) => {\n        const { stepSize, value } = this.props;\n        // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        /* eslint-disable-next-line deprecation/deprecation */\n        const { which } = event;\n        if (which === Keys.ARROW_DOWN || which === Keys.ARROW_LEFT) {\n            this.changeValue(value - stepSize);\n            // this key event has been handled! prevent browser scroll on up/down\n            event.preventDefault();\n        } else if (which === Keys.ARROW_UP || which === Keys.ARROW_RIGHT) {\n            this.changeValue(value + stepSize);\n            event.preventDefault();\n        }\n    };\n\n    private handleKeyUp = (event: React.KeyboardEvent<HTMLSpanElement>) => {\n        // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        /* eslint-disable-next-line deprecation/deprecation */\n        if ([Keys.ARROW_UP, Keys.ARROW_DOWN, Keys.ARROW_LEFT, Keys.ARROW_RIGHT].indexOf(event.which) >= 0) {\n            this.props.onRelease?.(this.props.value);\n        }\n    };\n\n    /** Clamp value and invoke callback if it differs from current value */\n    private changeValue(newValue: number, callback = this.props.onChange) {\n        newValue = this.clamp(newValue);\n        if (!isNaN(newValue) && this.props.value !== newValue) {\n            callback?.(newValue);\n        }\n        return newValue;\n    }\n\n    /** Clamp value between min and max props */\n    private clamp(value: number) {\n        return clamp(value, this.props.min, this.props.max);\n    }\n\n    private getHandleElementCenterPixel(handleElement: HTMLElement) {\n        const { handleMidpoint, handleOffset } = this.getHandleMidpointAndOffset(handleElement);\n        return handleOffset + handleMidpoint;\n    }\n\n    private getHandleMidpointAndOffset(handleElement: HTMLElement, useOppositeDimension = false) {\n        if (handleElement == null) {\n            return { handleMidpoint: 0, handleOffset: 0 };\n        }\n\n        const { vertical } = this.props;\n\n        // getBoundingClientRect().height includes border size; clientHeight does not.\n        const handleRect = handleElement.getBoundingClientRect();\n\n        const sizeKey = vertical\n            ? useOppositeDimension\n                ? \"width\"\n                : \"height\"\n            : useOppositeDimension\n            ? \"height\"\n            : \"width\";\n\n        // \"bottom\" value seems to be consistently incorrect, so explicitly\n        // calculate it using the window offset instead.\n        const handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n\n        return { handleMidpoint: handleRect[sizeKey] / 2, handleOffset };\n    }\n\n    private removeDocumentEventListeners() {\n        document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n        document.removeEventListener(\"mouseup\", this.endHandleMovement);\n        document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n        document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n        document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}