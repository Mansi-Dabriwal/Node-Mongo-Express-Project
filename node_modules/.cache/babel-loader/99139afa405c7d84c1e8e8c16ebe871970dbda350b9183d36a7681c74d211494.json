{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { Browser } from \"../../compatibility\";\nvar BUFFER_WIDTH_DEFAULT = 5;\nvar BUFFER_WIDTH_IE = 30;\nvar EditableText = /** @class */function (_super) {\n  __extends(EditableText, _super);\n  function EditableText(props, context) {\n    var _this = _super.call(this, props, context) || this;\n    _this.inputElement = null;\n    _this.valueElement = null;\n    _this.refHandlers = {\n      content: function (spanElement) {\n        _this.valueElement = spanElement;\n      },\n      input: function (input) {\n        if (input != null) {\n          _this.inputElement = input;\n          // temporary fix for #3882\n          if (!_this.props.alwaysRenderInput) {\n            _this.inputElement.focus();\n          }\n          if (_this.state != null && _this.state.isEditing) {\n            var supportsSelection = inputSupportsSelection(input);\n            if (supportsSelection) {\n              var length_1 = input.value.length;\n              input.setSelectionRange(_this.props.selectAllOnFocus ? 0 : length_1, length_1);\n            }\n            if (!supportsSelection || !_this.props.selectAllOnFocus) {\n              input.scrollLeft = input.scrollWidth;\n            }\n          }\n        }\n      }\n    };\n    _this.cancelEditing = function () {\n      var _a, _b, _c, _d;\n      var _e = _this.state,\n        lastValue = _e.lastValue,\n        value = _e.value;\n      _this.setState({\n        isEditing: false,\n        value: lastValue\n      });\n      if (value !== lastValue) {\n        (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, lastValue);\n      }\n      (_d = (_c = _this.props).onCancel) === null || _d === void 0 ? void 0 : _d.call(_c, lastValue);\n    };\n    _this.toggleEditing = function () {\n      var _a, _b;\n      if (_this.state.isEditing) {\n        var value = _this.state.value;\n        _this.setState({\n          isEditing: false,\n          lastValue: value\n        });\n        (_b = (_a = _this.props).onConfirm) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n      } else if (!_this.props.disabled) {\n        _this.setState({\n          isEditing: true\n        });\n      }\n    };\n    _this.handleFocus = function () {\n      var _a = _this.props,\n        alwaysRenderInput = _a.alwaysRenderInput,\n        disabled = _a.disabled,\n        selectAllOnFocus = _a.selectAllOnFocus;\n      if (!disabled) {\n        _this.setState({\n          isEditing: true\n        });\n      }\n      if (alwaysRenderInput && selectAllOnFocus && _this.inputElement != null) {\n        var length_2 = _this.inputElement.value.length;\n        _this.inputElement.setSelectionRange(0, length_2);\n      }\n    };\n    _this.handleTextChange = function (event) {\n      var _a, _b;\n      var value = event.target.value;\n      // state value should be updated only when uncontrolled\n      if (_this.props.value == null) {\n        _this.setState({\n          value: value\n        });\n      }\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    };\n    _this.handleKeyEvent = function (event) {\n      // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n      /* eslint-disable-next-line deprecation/deprecation */\n      var altKey = event.altKey,\n        ctrlKey = event.ctrlKey,\n        metaKey = event.metaKey,\n        shiftKey = event.shiftKey,\n        which = event.which;\n      if (which === Keys.ESCAPE) {\n        _this.cancelEditing();\n        return;\n      }\n      var hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;\n      if (which === Keys.ENTER) {\n        // prevent IE11 from full screening with alt + enter\n        // shift + enter adds a newline by default\n        if (altKey || shiftKey) {\n          event.preventDefault();\n        }\n        if (_this.props.confirmOnEnterKey && _this.props.multiline) {\n          if (event.target != null && hasModifierKey) {\n            insertAtCaret(event.target, \"\\n\");\n            _this.handleTextChange(event);\n          } else {\n            _this.toggleEditing();\n          }\n        } else if (!_this.props.multiline || hasModifierKey) {\n          _this.toggleEditing();\n        }\n      }\n    };\n    var value = props.value == null ? props.defaultValue : props.value;\n    _this.state = {\n      inputHeight: 0,\n      inputWidth: 0,\n      isEditing: props.isEditing === true && props.disabled === false,\n      lastValue: value,\n      value: value\n    };\n    return _this;\n  }\n  EditableText.prototype.render = function () {\n    var _a;\n    var _b;\n    var _c = this.props,\n      alwaysRenderInput = _c.alwaysRenderInput,\n      disabled = _c.disabled,\n      multiline = _c.multiline,\n      contentId = _c.contentId;\n    var value = (_b = this.props.value) !== null && _b !== void 0 ? _b : this.state.value;\n    var hasValue = value != null && value !== \"\";\n    var classes = classNames(Classes.EDITABLE_TEXT, Classes.intentClass(this.props.intent), (_a = {}, _a[Classes.DISABLED] = disabled, _a[Classes.EDITABLE_TEXT_EDITING] = this.state.isEditing, _a[Classes.EDITABLE_TEXT_PLACEHOLDER] = !hasValue, _a[Classes.MULTILINE] = multiline, _a), this.props.className);\n    var contentStyle;\n    if (multiline) {\n      // set height only in multiline mode when not editing\n      // otherwise we're measuring this element to determine appropriate height of text\n      contentStyle = {\n        height: !this.state.isEditing ? this.state.inputHeight : undefined\n      };\n    } else {\n      // minWidth only applies in single line mode (multiline == width 100%)\n      contentStyle = {\n        height: this.state.inputHeight,\n        lineHeight: this.state.inputHeight != null ? \"\".concat(this.state.inputHeight, \"px\") : undefined,\n        minWidth: this.props.minWidth\n      };\n    }\n    // If we are always rendering an input, then NEVER make the container div focusable.\n    // Otherwise, make container div focusable when not editing, so it can still be tabbed\n    // to focus (when the input is rendered, it is itself focusable so container div doesn't need to be)\n    var tabIndex = alwaysRenderInput || this.state.isEditing || disabled ? undefined : 0;\n    // we need the contents to be rendered while editing so that we can measure their height\n    // and size the container element responsively\n    var shouldHideContents = alwaysRenderInput && !this.state.isEditing;\n    var spanProps = contentId != null ? {\n      id: contentId\n    } : {};\n    return React.createElement(\"div\", {\n      className: classes,\n      onFocus: this.handleFocus,\n      tabIndex: tabIndex\n    }, alwaysRenderInput || this.state.isEditing ? this.renderInput(value) : undefined, shouldHideContents ? undefined : React.createElement(\"span\", __assign({}, spanProps, {\n      className: Classes.EDITABLE_TEXT_CONTENT,\n      ref: this.refHandlers.content,\n      style: contentStyle\n    }), hasValue ? value : this.props.placeholder));\n  };\n  EditableText.prototype.componentDidMount = function () {\n    this.updateInputDimensions();\n  };\n  EditableText.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b;\n    var newState = {};\n    // allow setting the value to undefined/null in controlled mode\n    if (this.props.value !== prevProps.value && (prevProps.value != null || this.props.value != null)) {\n      newState.value = this.props.value;\n    }\n    if (this.props.isEditing != null && this.props.isEditing !== prevProps.isEditing) {\n      newState.isEditing = this.props.isEditing;\n    }\n    if (this.props.disabled || this.props.disabled == null && prevProps.disabled) {\n      newState.isEditing = false;\n    }\n    this.setState(newState);\n    if (this.state.isEditing && !prevState.isEditing) {\n      (_b = (_a = this.props).onEdit) === null || _b === void 0 ? void 0 : _b.call(_a, this.state.value);\n    }\n    // updateInputDimensions is an expensive method. Call it only when the props\n    // it depends on change\n    if (this.state.value !== prevState.value || this.props.alwaysRenderInput !== prevProps.alwaysRenderInput || this.props.maxLines !== prevProps.maxLines || this.props.minLines !== prevProps.minLines || this.props.minWidth !== prevProps.minWidth || this.props.multiline !== prevProps.multiline) {\n      this.updateInputDimensions();\n    }\n  };\n  EditableText.prototype.renderInput = function (value) {\n    var _a = this.props,\n      disabled = _a.disabled,\n      maxLength = _a.maxLength,\n      multiline = _a.multiline,\n      type = _a.type,\n      placeholder = _a.placeholder;\n    var props = {\n      className: Classes.EDITABLE_TEXT_INPUT,\n      disabled: disabled,\n      maxLength: maxLength,\n      onBlur: this.toggleEditing,\n      onChange: this.handleTextChange,\n      onKeyDown: this.handleKeyEvent,\n      placeholder: placeholder,\n      value: value\n    };\n    var _b = this.state,\n      inputHeight = _b.inputHeight,\n      inputWidth = _b.inputWidth;\n    if (inputHeight !== 0 && inputWidth !== 0) {\n      props.style = {\n        height: inputHeight,\n        lineHeight: !multiline && inputHeight != null ? \"\".concat(inputHeight, \"px\") : undefined,\n        width: multiline ? \"100%\" : inputWidth\n      };\n    }\n    return multiline ? React.createElement(\"textarea\", __assign({\n      ref: this.refHandlers.input\n    }, props)) : React.createElement(\"input\", __assign({\n      ref: this.refHandlers.input,\n      type: type\n    }, props));\n  };\n  EditableText.prototype.updateInputDimensions = function () {\n    if (this.valueElement != null) {\n      var _a = this.props,\n        maxLines = _a.maxLines,\n        minLines = _a.minLines,\n        minWidth = _a.minWidth,\n        multiline = _a.multiline;\n      var _b = this.valueElement,\n        parentElement_1 = _b.parentElement,\n        textContent = _b.textContent;\n      var _c = this.valueElement,\n        scrollHeight_1 = _c.scrollHeight,\n        scrollWidth = _c.scrollWidth;\n      var lineHeight = getLineHeight(this.valueElement);\n      // add one line to computed <span> height if text ends in newline\n      // because <span> collapses that trailing whitespace but <textarea> shows it\n      if (multiline && this.state.isEditing && /\\n$/.test(textContent !== null && textContent !== void 0 ? textContent : \"\")) {\n        scrollHeight_1 += lineHeight;\n      }\n      if (lineHeight > 0) {\n        // line height could be 0 if the isNaN block from getLineHeight kicks in\n        scrollHeight_1 = clamp(scrollHeight_1, minLines * lineHeight, maxLines * lineHeight);\n      }\n      // Chrome's input caret height misaligns text so the line-height must be larger than font-size.\n      // The computed scrollHeight must also account for a larger inherited line-height from the parent.\n      scrollHeight_1 = Math.max(scrollHeight_1, getFontSize(this.valueElement) + 1, getLineHeight(parentElement_1));\n      // Need to add a small buffer so text does not shift prior to resizing, causing an infinite loop.\n      // IE needs a larger buffer than other browsers.\n      scrollWidth += Browser.isInternetExplorer() ? BUFFER_WIDTH_IE : BUFFER_WIDTH_DEFAULT;\n      this.setState({\n        inputHeight: scrollHeight_1,\n        inputWidth: Math.max(scrollWidth, minWidth)\n      });\n      // synchronizes the ::before pseudo-element's height while editing for Chrome 53\n      if (multiline && this.state.isEditing) {\n        this.setTimeout(function () {\n          return parentElement_1.style.height = \"\".concat(scrollHeight_1, \"px\");\n        });\n      }\n    }\n  };\n  EditableText.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".EditableText\");\n  EditableText.defaultProps = {\n    alwaysRenderInput: false,\n    confirmOnEnterKey: false,\n    defaultValue: \"\",\n    disabled: false,\n    maxLines: Infinity,\n    minLines: 1,\n    minWidth: 80,\n    multiline: false,\n    placeholder: \"Click to Edit\",\n    type: \"text\"\n  };\n  return EditableText;\n}(AbstractPureComponent2);\nexport { EditableText };\nfunction getFontSize(element) {\n  var fontSize = getComputedStyle(element).fontSize;\n  return fontSize === \"\" ? 0 : parseInt(fontSize.slice(0, -2), 10);\n}\nfunction getLineHeight(element) {\n  // getComputedStyle() => 18.0001px => 18\n  var lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10);\n  // this check will be true if line-height is a keyword like \"normal\"\n  if (isNaN(lineHeight)) {\n    // @see http://stackoverflow.com/a/18430767/6342931\n    var line = document.createElement(\"span\");\n    line.innerHTML = \"<br>\";\n    element.appendChild(line);\n    var singleLineHeight = element.offsetHeight;\n    line.innerHTML = \"<br><br>\";\n    var doubleLineHeight = element.offsetHeight;\n    element.removeChild(line);\n    // this can return 0 in edge cases\n    lineHeight = doubleLineHeight - singleLineHeight;\n  }\n  return lineHeight;\n}\nfunction insertAtCaret(el, text) {\n  var selectionEnd = el.selectionEnd,\n    selectionStart = el.selectionStart,\n    value = el.value;\n  if (selectionStart >= 0) {\n    var before_1 = value.substring(0, selectionStart);\n    var after_1 = value.substring(selectionEnd, value.length);\n    var len = text.length;\n    el.value = \"\".concat(before_1).concat(text).concat(after_1);\n    el.selectionStart = selectionStart + len;\n    el.selectionEnd = selectionStart + len;\n  }\n}\nfunction inputSupportsSelection(input) {\n  switch (input.type) {\n    // HTMLTextAreaElement\n    case \"textarea\":\n      return true;\n    // HTMLInputElement\n    // see https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n    case \"text\":\n    case \"search\":\n    case \"tel\":\n    case \"url\":\n    case \"password\":\n      return true;\n    default:\n      return false;\n  }\n}","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","Keys","DISPLAYNAME_PREFIX","clamp","Browser","BUFFER_WIDTH_DEFAULT","BUFFER_WIDTH_IE","__extends","props","context","_super","_this","content","spanElement","valueElement","input","inputElement","alwaysRenderInput","focus","state","isEditing","supportsSelection","inputSupportsSelection","value","setSelectionRange","selectAllOnFocus","length_1","scrollLeft","scrollWidth","lastValue","setState","onChange","onCancel","onConfirm","disabled","length_2","event","target","ctrlKey","metaKey","shiftKey","which","ESCAPE","cancelEditing","hasModifierKey","altKey","ENTER","preventDefault","confirmOnEnterKey","multiline","insertAtCaret","handleTextChange","toggleEditing","defaultValue","inputHeight","inputWidth","EditableText","contentId","hasValue","classes","EDITABLE_TEXT","intentClass","intent","_a","DISABLED","EDITABLE_TEXT_EDITING","EDITABLE_TEXT_PLACEHOLDER","MULTILINE","className","contentStyle","height","undefined","lineHeight","minWidth","tabIndex","shouldHideContents","spanProps","id","onFocus","handleFocus","renderInput","EDITABLE_TEXT_CONTENT","ref","refHandlers","style","placeholder","updateInputDimensions","prevProps","prevState","newState","onEdit","maxLines","minLines","maxLength","type","EDITABLE_TEXT_INPUT","onBlur","onKeyDown","handleKeyEvent","width","parentElement_1","textContent","scrollHeight_1","getLineHeight","test","Math","max","getFontSize","isInternetExplorer","setTimeout","Infinity","element","fontSize","getComputedStyle","parseInt","slice","isNaN","line","document","createElement","innerHTML","appendChild","singleLineHeight","offsetHeight","doubleLineHeight","removeChild","el","text","selectionStart","before_1","substring","after_1","selectionEnd","length","len"],"sources":["/Users/mansidabriwal/Documents/Web design class/React-Assignment/react-app/node_modules/@blueprintjs/core/src/components/editable-text/editableText.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX, IntentProps, Props } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { Browser } from \"../../compatibility\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type EditableTextProps = IEditableTextProps;\n/** @deprecated use EditableTextProps */\nexport interface IEditableTextProps extends IntentProps, Props {\n    /**\n     * EXPERIMENTAL FEATURE.\n     *\n     * When true, this forces the component to _always_ render an editable input (or textarea)\n     * both when the component is focussed and unfocussed, instead of the component's default\n     * behavior of switching between a text span and a text input upon interaction.\n     *\n     * This behavior can help in certain applications where, for example, a custom right-click\n     * context menu is used to supply clipboard copy and paste functionality.\n     *\n     * @default false\n     */\n    alwaysRenderInput?: boolean;\n\n    /**\n     * If `true` and in multiline mode, the `enter` key will trigger onConfirm and `mod+enter`\n     * will insert a newline. If `false`, the key bindings are inverted such that `enter`\n     * adds a newline.\n     *\n     * @default false\n     */\n    confirmOnEnterKey?: boolean;\n\n    /** Default text value of uncontrolled input. */\n    defaultValue?: string;\n\n    /**\n     * Whether the text can be edited.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /** Whether the component is currently being edited. */\n    isEditing?: boolean;\n\n    /** Maximum number of characters allowed. Unlimited by default. */\n    maxLength?: number;\n\n    /** Minimum width in pixels of the input, when not `multiline`. */\n    minWidth?: number;\n\n    /**\n     * Whether the component supports multiple lines of text.\n     * This prop should not be changed during the component's lifetime.\n     *\n     * @default false\n     */\n    multiline?: boolean;\n\n    /**\n     * Maximum number of lines before scrolling begins, when `multiline`.\n     */\n    maxLines?: number;\n\n    /**\n     * Minimum number of lines (essentially minimum height), when `multiline`.\n     *\n     * @default 1\n     */\n    minLines?: number;\n\n    /**\n     * Placeholder text when there is no value.\n     *\n     * @default \"Click to Edit\"\n     */\n    placeholder?: string;\n\n    /**\n     * Whether the entire text field should be selected on focus.\n     * If `false`, the cursor is placed at the end of the text.\n     * This prop is ignored on inputs with type other then text, search, url, tel and password. See https://html.spec.whatwg.org/multipage/input.html#do-not-apply for details.\n     *\n     * @default false\n     */\n    selectAllOnFocus?: boolean;\n\n    /**\n     * The type of input that should be shown, when not `multiline`.\n     */\n    type?: string;\n\n    /** Text value of controlled input. */\n    value?: string;\n\n    /** ID attribute to pass to the underlying element that contains the text contents. This allows for referencing via aria attributes */\n    contentId?: string;\n\n    /** Callback invoked when user cancels input with the `esc` key. Receives last confirmed value. */\n    onCancel?(value: string): void;\n\n    /** Callback invoked when user changes input in any way. */\n    onChange?(value: string): void;\n\n    /** Callback invoked when user confirms value with `enter` key or by blurring input. */\n    onConfirm?(value: string): void;\n\n    /** Callback invoked after the user enters edit mode. */\n    onEdit?(value: string | undefined): void;\n}\n\nexport interface IEditableTextState {\n    /** Pixel height of the input, measured from span size */\n    inputHeight?: number;\n    /** Pixel width of the input, measured from span size */\n    inputWidth?: number;\n    /** Whether the value is currently being edited */\n    isEditing?: boolean;\n    /** The last confirmed value */\n    lastValue?: string;\n    /** The controlled input value, may be different from prop during editing */\n    value?: string;\n}\n\nconst BUFFER_WIDTH_DEFAULT = 5;\nconst BUFFER_WIDTH_IE = 30;\n\nexport class EditableText extends AbstractPureComponent2<EditableTextProps, IEditableTextState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.EditableText`;\n\n    public static defaultProps: EditableTextProps = {\n        alwaysRenderInput: false,\n        confirmOnEnterKey: false,\n        defaultValue: \"\",\n        disabled: false,\n        maxLines: Infinity,\n        minLines: 1,\n        minWidth: 80,\n        multiline: false,\n        placeholder: \"Click to Edit\",\n        type: \"text\",\n    };\n\n    private inputElement: HTMLInputElement | HTMLTextAreaElement | null = null;\n\n    private valueElement: HTMLSpanElement | null = null;\n\n    private refHandlers = {\n        content: (spanElement: HTMLSpanElement | null) => {\n            this.valueElement = spanElement;\n        },\n        input: (input: HTMLInputElement | HTMLTextAreaElement | null) => {\n            if (input != null) {\n                this.inputElement = input;\n\n                // temporary fix for #3882\n                if (!this.props.alwaysRenderInput) {\n                    this.inputElement.focus();\n                }\n\n                if (this.state != null && this.state.isEditing) {\n                    const supportsSelection = inputSupportsSelection(input);\n                    if (supportsSelection) {\n                        const { length } = input.value;\n                        input.setSelectionRange(this.props.selectAllOnFocus ? 0 : length, length);\n                    }\n                    if (!supportsSelection || !this.props.selectAllOnFocus) {\n                        input.scrollLeft = input.scrollWidth;\n                    }\n                }\n            }\n        },\n    };\n\n    public constructor(props: EditableTextProps, context?: any) {\n        super(props, context);\n\n        const value = props.value == null ? props.defaultValue : props.value;\n        this.state = {\n            inputHeight: 0,\n            inputWidth: 0,\n            isEditing: props.isEditing === true && props.disabled === false,\n            lastValue: value,\n            value,\n        };\n    }\n\n    public render() {\n        const { alwaysRenderInput, disabled, multiline, contentId } = this.props;\n        const value = this.props.value ?? this.state.value;\n        const hasValue = value != null && value !== \"\";\n\n        const classes = classNames(\n            Classes.EDITABLE_TEXT,\n            Classes.intentClass(this.props.intent),\n            {\n                [Classes.DISABLED]: disabled,\n                [Classes.EDITABLE_TEXT_EDITING]: this.state.isEditing,\n                [Classes.EDITABLE_TEXT_PLACEHOLDER]: !hasValue,\n                [Classes.MULTILINE]: multiline,\n            },\n            this.props.className,\n        );\n\n        let contentStyle: React.CSSProperties;\n        if (multiline) {\n            // set height only in multiline mode when not editing\n            // otherwise we're measuring this element to determine appropriate height of text\n            contentStyle = { height: !this.state.isEditing ? this.state.inputHeight : undefined };\n        } else {\n            // minWidth only applies in single line mode (multiline == width 100%)\n            contentStyle = {\n                height: this.state.inputHeight,\n                lineHeight: this.state.inputHeight != null ? `${this.state.inputHeight}px` : undefined,\n                minWidth: this.props.minWidth,\n            };\n        }\n\n        // If we are always rendering an input, then NEVER make the container div focusable.\n        // Otherwise, make container div focusable when not editing, so it can still be tabbed\n        // to focus (when the input is rendered, it is itself focusable so container div doesn't need to be)\n        const tabIndex = alwaysRenderInput || this.state.isEditing || disabled ? undefined : 0;\n\n        // we need the contents to be rendered while editing so that we can measure their height\n        // and size the container element responsively\n        const shouldHideContents = alwaysRenderInput && !this.state.isEditing;\n\n        const spanProps: React.HTMLProps<HTMLSpanElement> = contentId != null ? { id: contentId } : {};\n\n        return (\n            <div className={classes} onFocus={this.handleFocus} tabIndex={tabIndex}>\n                {alwaysRenderInput || this.state.isEditing ? this.renderInput(value) : undefined}\n                {shouldHideContents ? undefined : (\n                    <span\n                        {...spanProps}\n                        className={Classes.EDITABLE_TEXT_CONTENT}\n                        ref={this.refHandlers.content}\n                        style={contentStyle}\n                    >\n                        {hasValue ? value : this.props.placeholder}\n                    </span>\n                )}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateInputDimensions();\n    }\n\n    public componentDidUpdate(prevProps: EditableTextProps, prevState: IEditableTextState) {\n        const newState: IEditableTextState = {};\n        // allow setting the value to undefined/null in controlled mode\n        if (this.props.value !== prevProps.value && (prevProps.value != null || this.props.value != null)) {\n            newState.value = this.props.value;\n        }\n        if (this.props.isEditing != null && this.props.isEditing !== prevProps.isEditing) {\n            newState.isEditing = this.props.isEditing;\n        }\n        if (this.props.disabled || (this.props.disabled == null && prevProps.disabled)) {\n            newState.isEditing = false;\n        }\n\n        this.setState(newState);\n\n        if (this.state.isEditing && !prevState.isEditing) {\n            this.props.onEdit?.(this.state.value);\n        }\n        // updateInputDimensions is an expensive method. Call it only when the props\n        // it depends on change\n        if (\n            this.state.value !== prevState.value ||\n            this.props.alwaysRenderInput !== prevProps.alwaysRenderInput ||\n            this.props.maxLines !== prevProps.maxLines ||\n            this.props.minLines !== prevProps.minLines ||\n            this.props.minWidth !== prevProps.minWidth ||\n            this.props.multiline !== prevProps.multiline\n        ) {\n            this.updateInputDimensions();\n        }\n    }\n\n    public cancelEditing = () => {\n        const { lastValue, value } = this.state;\n        this.setState({ isEditing: false, value: lastValue });\n        if (value !== lastValue) {\n            this.props.onChange?.(lastValue!);\n        }\n        this.props.onCancel?.(lastValue!);\n    };\n\n    public toggleEditing = () => {\n        if (this.state.isEditing) {\n            const { value } = this.state;\n            this.setState({ isEditing: false, lastValue: value });\n            this.props.onConfirm?.(value!);\n        } else if (!this.props.disabled) {\n            this.setState({ isEditing: true });\n        }\n    };\n\n    private handleFocus = () => {\n        const { alwaysRenderInput, disabled, selectAllOnFocus } = this.props;\n\n        if (!disabled) {\n            this.setState({ isEditing: true });\n        }\n\n        if (alwaysRenderInput && selectAllOnFocus && this.inputElement != null) {\n            const { length } = this.inputElement.value;\n            this.inputElement.setSelectionRange(0, length);\n        }\n    };\n\n    private handleTextChange = (event: React.FormEvent<HTMLElement>) => {\n        const value = (event.target as HTMLInputElement).value;\n        // state value should be updated only when uncontrolled\n        if (this.props.value == null) {\n            this.setState({ value });\n        }\n        this.props.onChange?.(value);\n    };\n\n    private handleKeyEvent = (event: React.KeyboardEvent<HTMLElement>) => {\n        // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        /* eslint-disable-next-line deprecation/deprecation */\n        const { altKey, ctrlKey, metaKey, shiftKey, which } = event;\n        if (which === Keys.ESCAPE) {\n            this.cancelEditing();\n            return;\n        }\n\n        const hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;\n        if (which === Keys.ENTER) {\n            // prevent IE11 from full screening with alt + enter\n            // shift + enter adds a newline by default\n            if (altKey || shiftKey) {\n                event.preventDefault();\n            }\n\n            if (this.props.confirmOnEnterKey && this.props.multiline) {\n                if (event.target != null && hasModifierKey) {\n                    insertAtCaret(event.target as HTMLTextAreaElement, \"\\n\");\n                    this.handleTextChange(event);\n                } else {\n                    this.toggleEditing();\n                }\n            } else if (!this.props.multiline || hasModifierKey) {\n                this.toggleEditing();\n            }\n        }\n    };\n\n    private renderInput(value: string | undefined) {\n        const { disabled, maxLength, multiline, type, placeholder } = this.props;\n        const props: React.InputHTMLAttributes<HTMLInputElement | HTMLTextAreaElement> = {\n            className: Classes.EDITABLE_TEXT_INPUT,\n            disabled,\n            maxLength,\n            onBlur: this.toggleEditing,\n            onChange: this.handleTextChange,\n            onKeyDown: this.handleKeyEvent,\n            placeholder,\n            value,\n        };\n\n        const { inputHeight, inputWidth } = this.state;\n        if (inputHeight !== 0 && inputWidth !== 0) {\n            props.style = {\n                height: inputHeight,\n                lineHeight: !multiline && inputHeight != null ? `${inputHeight}px` : undefined,\n                width: multiline ? \"100%\" : inputWidth,\n            };\n        }\n\n        return multiline ? (\n            <textarea ref={this.refHandlers.input} {...props} />\n        ) : (\n            <input ref={this.refHandlers.input} type={type} {...props} />\n        );\n    }\n\n    private updateInputDimensions() {\n        if (this.valueElement != null) {\n            const { maxLines, minLines, minWidth, multiline } = this.props;\n            const { parentElement, textContent } = this.valueElement;\n            let { scrollHeight, scrollWidth } = this.valueElement;\n            const lineHeight = getLineHeight(this.valueElement);\n            // add one line to computed <span> height if text ends in newline\n            // because <span> collapses that trailing whitespace but <textarea> shows it\n            if (multiline && this.state.isEditing && /\\n$/.test(textContent ?? \"\")) {\n                scrollHeight += lineHeight;\n            }\n            if (lineHeight > 0) {\n                // line height could be 0 if the isNaN block from getLineHeight kicks in\n                scrollHeight = clamp(scrollHeight, minLines! * lineHeight, maxLines! * lineHeight);\n            }\n            // Chrome's input caret height misaligns text so the line-height must be larger than font-size.\n            // The computed scrollHeight must also account for a larger inherited line-height from the parent.\n            scrollHeight = Math.max(scrollHeight, getFontSize(this.valueElement) + 1, getLineHeight(parentElement!));\n            // Need to add a small buffer so text does not shift prior to resizing, causing an infinite loop.\n            // IE needs a larger buffer than other browsers.\n            scrollWidth += Browser.isInternetExplorer() ? BUFFER_WIDTH_IE : BUFFER_WIDTH_DEFAULT;\n\n            this.setState({\n                inputHeight: scrollHeight,\n                inputWidth: Math.max(scrollWidth, minWidth!),\n            });\n            // synchronizes the ::before pseudo-element's height while editing for Chrome 53\n            if (multiline && this.state.isEditing) {\n                this.setTimeout(() => (parentElement!.style.height = `${scrollHeight}px`));\n            }\n        }\n    }\n}\n\nfunction getFontSize(element: HTMLElement) {\n    const fontSize = getComputedStyle(element).fontSize;\n    return fontSize === \"\" ? 0 : parseInt(fontSize.slice(0, -2), 10);\n}\n\nfunction getLineHeight(element: HTMLElement) {\n    // getComputedStyle() => 18.0001px => 18\n    let lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10);\n    // this check will be true if line-height is a keyword like \"normal\"\n    if (isNaN(lineHeight)) {\n        // @see http://stackoverflow.com/a/18430767/6342931\n        const line = document.createElement(\"span\");\n        line.innerHTML = \"<br>\";\n        element.appendChild(line);\n        const singleLineHeight = element.offsetHeight;\n        line.innerHTML = \"<br><br>\";\n        const doubleLineHeight = element.offsetHeight;\n        element.removeChild(line);\n        // this can return 0 in edge cases\n        lineHeight = doubleLineHeight - singleLineHeight;\n    }\n    return lineHeight;\n}\n\nfunction insertAtCaret(el: HTMLTextAreaElement, text: string) {\n    const { selectionEnd, selectionStart, value } = el;\n    if (selectionStart >= 0) {\n        const before = value.substring(0, selectionStart);\n        const after = value.substring(selectionEnd, value.length);\n        const len = text.length;\n        el.value = `${before}${text}${after}`;\n        el.selectionStart = selectionStart + len;\n        el.selectionEnd = selectionStart + len;\n    }\n}\n\nfunction inputSupportsSelection(input: HTMLInputElement | HTMLTextAreaElement) {\n    switch (input.type) {\n        // HTMLTextAreaElement\n        case \"textarea\":\n            return true;\n        // HTMLInputElement\n        // see https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n        case \"text\":\n        case \"search\":\n        case \"tel\":\n        case \"url\":\n        case \"password\":\n            return true;\n        default:\n            return false;\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}