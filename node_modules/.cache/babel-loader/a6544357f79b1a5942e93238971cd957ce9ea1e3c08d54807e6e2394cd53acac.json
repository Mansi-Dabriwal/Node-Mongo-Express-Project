{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, Intent } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, HandleType } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n/**\n * SFC used to pass slider handle props to a `MultiSlider`.\n * This element is not rendered directly.\n */\nvar MultiSliderHandle = function () {\n  return null;\n};\nMultiSliderHandle.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".MultiSliderHandle\");\nvar MultiSlider = /** @class */function (_super) {\n  __extends(MultiSlider, _super);\n  function MultiSlider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      labelPrecision: getLabelPrecision(_this.props),\n      tickSize: 0,\n      tickSizeRatio: 0\n    };\n    _this.handleElements = [];\n    _this.trackElement = null;\n    _this.addHandleRef = function (ref) {\n      if (ref != null) {\n        _this.handleElements.push(ref);\n      }\n    };\n    _this.maybeHandleTrackClick = function (event) {\n      if (_this.canHandleTrackEvent(event)) {\n        var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {\n          return handle.mouseEventClientOffset(event);\n        });\n        if (foundHandle) {\n          foundHandle.beginHandleMovement(event);\n        }\n      }\n    };\n    _this.maybeHandleTrackTouch = function (event) {\n      if (_this.canHandleTrackEvent(event)) {\n        var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {\n          return handle.touchEventClientOffset(event);\n        });\n        if (foundHandle) {\n          foundHandle.beginHandleTouchMovement(event);\n        }\n      }\n    };\n    _this.canHandleTrackEvent = function (event) {\n      var target = event.target;\n      // ensure event does not come from inside the handle\n      return !_this.props.disabled && target.closest(\".\".concat(Classes.SLIDER_HANDLE)) == null;\n    };\n    _this.getHandlerForIndex = function (index, callback) {\n      return function (newValue) {\n        callback === null || callback === void 0 ? void 0 : callback(_this.getNewHandleValues(newValue, index));\n      };\n    };\n    _this.handleChange = function (newValues) {\n      var _a, _b;\n      var handleProps = getSortedInteractiveHandleProps(_this.props);\n      var oldValues = handleProps.map(function (handle) {\n        return handle.value;\n      });\n      if (!Utils.arraysEqual(newValues, oldValues)) {\n        (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n        handleProps.forEach(function (handle, index) {\n          var _a;\n          if (oldValues[index] !== newValues[index]) {\n            (_a = handle.onChange) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n          }\n        });\n      }\n    };\n    _this.handleRelease = function (newValues) {\n      var _a, _b;\n      var handleProps = getSortedInteractiveHandleProps(_this.props);\n      (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n      handleProps.forEach(function (handle, index) {\n        var _a;\n        (_a = handle.onRelease) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n      });\n    };\n    return _this;\n  }\n  MultiSlider.getDerivedStateFromProps = function (props) {\n    return {\n      labelPrecision: MultiSlider.getLabelPrecision(props)\n    };\n  };\n  MultiSlider.getLabelPrecision = function (_a) {\n    var labelPrecision = _a.labelPrecision,\n      stepSize = _a.stepSize;\n    // infer default label precision from stepSize because that's how much the handle moves.\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n  };\n  MultiSlider.prototype.getSnapshotBeforeUpdate = function (prevProps) {\n    var prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n    var newHandleProps = getSortedInteractiveHandleProps(this.props);\n    if (newHandleProps.length !== prevHandleProps.length) {\n      // clear refs\n      this.handleElements = [];\n    }\n    return null;\n  };\n  MultiSlider.prototype.render = function () {\n    var _a;\n    var _this = this;\n    var classes = classNames(Classes.SLIDER, (_a = {}, _a[Classes.DISABLED] = this.props.disabled, _a[\"\".concat(Classes.SLIDER, \"-unlabeled\")] = this.props.labelRenderer === false, _a[Classes.VERTICAL] = this.props.vertical, _a), this.props.className);\n    return React.createElement(\"div\", {\n      className: classes,\n      onMouseDown: this.maybeHandleTrackClick,\n      onTouchStart: this.maybeHandleTrackTouch\n    }, React.createElement(\"div\", {\n      className: Classes.SLIDER_TRACK,\n      ref: function (ref) {\n        return _this.trackElement = ref;\n      }\n    }, this.renderTracks()), React.createElement(\"div\", {\n      className: Classes.SLIDER_AXIS\n    }, this.renderLabels()), this.renderHandles());\n  };\n  MultiSlider.prototype.componentDidMount = function () {\n    this.updateTickSize();\n  };\n  MultiSlider.prototype.componentDidUpdate = function (prevProps, prevState) {\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n    this.updateTickSize();\n  };\n  MultiSlider.prototype.validateProps = function (props) {\n    if (props.stepSize <= 0) {\n      throw new Error(Errors.SLIDER_ZERO_STEP);\n    }\n    if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n      throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n    }\n    if (props.labelStepSize !== undefined && props.labelStepSize <= 0) {\n      throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n    }\n    var anyInvalidChildren = false;\n    React.Children.forEach(props.children, function (child) {\n      // allow boolean coercion to omit nulls and false values\n      if (child && !Utils.isElementOfType(child, MultiSlider.Handle)) {\n        anyInvalidChildren = true;\n      }\n    });\n    if (anyInvalidChildren) {\n      throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n    }\n  };\n  MultiSlider.prototype.formatLabel = function (value, isHandleTooltip) {\n    if (isHandleTooltip === void 0) {\n      isHandleTooltip = false;\n    }\n    var labelRenderer = this.props.labelRenderer;\n    if (labelRenderer === false) {\n      return undefined;\n    } else if (Utils.isFunction(labelRenderer)) {\n      return labelRenderer(value, {\n        isHandleTooltip: isHandleTooltip\n      });\n    } else {\n      return value.toFixed(this.state.labelPrecision);\n    }\n  };\n  MultiSlider.prototype.renderLabels = function () {\n    var _this = this;\n    if (this.props.labelRenderer === false) {\n      return null;\n    }\n    var values = this.getLabelValues();\n    var _a = this.props,\n      max = _a.max,\n      min = _a.min;\n    var labels = values.map(function (step, i) {\n      var offsetPercentage = formatPercentage((step - min) / (max - min));\n      var style = _this.props.vertical ? {\n        bottom: offsetPercentage\n      } : {\n        left: offsetPercentage\n      };\n      return React.createElement(\"div\", {\n        className: Classes.SLIDER_LABEL,\n        key: i,\n        style: style\n      }, _this.formatLabel(step));\n    });\n    return labels;\n  };\n  MultiSlider.prototype.renderTracks = function () {\n    var trackStops = getSortedHandleProps(this.props);\n    trackStops.push({\n      value: this.props.max\n    });\n    // render from current to previous, then increment previous\n    var previous = {\n      value: this.props.min\n    };\n    var handles = [];\n    for (var index = 0; index < trackStops.length; index++) {\n      var current = trackStops[index];\n      handles.push(this.renderTrackFill(index, previous, current));\n      previous = current;\n    }\n    return handles;\n  };\n  MultiSlider.prototype.renderTrackFill = function (index, start, end) {\n    // ensure startRatio <= endRatio\n    var _a = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(function (left, right) {\n        return left - right;\n      }),\n      startRatio = _a[0],\n      endRatio = _a[1];\n    var startOffset = formatPercentage(startRatio);\n    var endOffset = formatPercentage(1 - endRatio);\n    var orientationStyle = this.props.vertical ? {\n      bottom: startOffset,\n      top: endOffset,\n      left: 0\n    } : {\n      left: startOffset,\n      right: endOffset,\n      top: 0\n    };\n    var style = __assign(__assign({}, orientationStyle), start.trackStyleAfter || end.trackStyleBefore || {});\n    var classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n    return React.createElement(\"div\", {\n      key: \"track-\".concat(index),\n      className: classes,\n      style: style\n    });\n  };\n  MultiSlider.prototype.renderHandles = function () {\n    var _this = this;\n    var _a = this.props,\n      disabled = _a.disabled,\n      max = _a.max,\n      min = _a.min,\n      stepSize = _a.stepSize,\n      vertical = _a.vertical;\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n    if (handleProps.length === 0) {\n      return null;\n    }\n    return handleProps.map(function (_a, index) {\n      var _b;\n      var value = _a.value,\n        type = _a.type,\n        className = _a.className,\n        htmlProps = _a.htmlProps;\n      return React.createElement(Handle, {\n        htmlProps: htmlProps,\n        className: classNames((_b = {}, _b[Classes.START] = type === HandleType.START, _b[Classes.END] = type === HandleType.END, _b), className),\n        disabled: disabled,\n        key: \"\".concat(index, \"-\").concat(handleProps.length),\n        label: _this.formatLabel(value, true),\n        max: max,\n        min: min,\n        onChange: _this.getHandlerForIndex(index, _this.handleChange),\n        onRelease: _this.getHandlerForIndex(index, _this.handleRelease),\n        ref: _this.addHandleRef,\n        stepSize: stepSize,\n        tickSize: _this.state.tickSize,\n        tickSizeRatio: _this.state.tickSizeRatio,\n        value: value,\n        vertical: vertical\n      });\n    });\n  };\n  MultiSlider.prototype.nearestHandleForValue = function (handles, getOffset) {\n    return argMin(handles, function (handle) {\n      var offset = getOffset(handle);\n      var offsetValue = handle.clientToValue(offset);\n      var handleValue = handle.props.value;\n      return Math.abs(offsetValue - handleValue);\n    });\n  };\n  MultiSlider.prototype.getNewHandleValues = function (newValue, oldIndex) {\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n    var oldValues = handleProps.map(function (handle) {\n      return handle.value;\n    });\n    var newValues = oldValues.slice();\n    newValues[oldIndex] = newValue;\n    newValues.sort(function (left, right) {\n      return left - right;\n    });\n    var newIndex = newValues.indexOf(newValue);\n    var lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n    if (lockIndex === -1) {\n      fillValues(newValues, oldIndex, newIndex, newValue);\n    } else {\n      // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n      var lockValue = oldValues[lockIndex];\n      fillValues(oldValues, oldIndex, lockIndex, lockValue);\n      return oldValues;\n    }\n    return newValues;\n  };\n  MultiSlider.prototype.findFirstLockedHandleIndex = function (startIndex, endIndex) {\n    var inc = startIndex < endIndex ? 1 : -1;\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n    for (var index = startIndex + inc; index !== endIndex + inc; index += inc) {\n      if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n        return index;\n      }\n    }\n    return -1;\n  };\n  MultiSlider.prototype.getLabelValues = function () {\n    var _a = this.props,\n      labelStepSize = _a.labelStepSize,\n      labelValues = _a.labelValues,\n      min = _a.min,\n      max = _a.max;\n    var values = [];\n    if (labelValues !== undefined) {\n      values = labelValues.slice();\n    } else {\n      for (var i = min; i < max || Utils.approxEqual(i, max); i += labelStepSize !== null && labelStepSize !== void 0 ? labelStepSize : 1) {\n        values.push(i);\n      }\n    }\n    return values;\n  };\n  MultiSlider.prototype.getOffsetRatio = function (value) {\n    return Utils.clamp((value - this.props.min) * this.state.tickSizeRatio, 0, 1);\n  };\n  MultiSlider.prototype.getTrackIntent = function (start, end) {\n    if (!this.props.showTrackFill) {\n      return Intent.NONE;\n    }\n    if (start.intentAfter !== undefined) {\n      return start.intentAfter;\n    } else if (end !== undefined && end.intentBefore !== undefined) {\n      return end.intentBefore;\n    }\n    return this.props.defaultTrackIntent;\n  };\n  MultiSlider.prototype.updateTickSize = function () {\n    if (this.trackElement != null) {\n      var trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n      var tickSizeRatio = 1 / (this.props.max - this.props.min);\n      var tickSize = trackSize * tickSizeRatio;\n      this.setState({\n        tickSize: tickSize,\n        tickSizeRatio: tickSizeRatio\n      });\n    }\n  };\n  MultiSlider.defaultSliderProps = {\n    disabled: false,\n    max: 10,\n    min: 0,\n    showTrackFill: true,\n    stepSize: 1,\n    vertical: false\n  };\n  MultiSlider.defaultProps = __assign(__assign({}, MultiSlider.defaultSliderProps), {\n    defaultTrackIntent: Intent.NONE\n  });\n  MultiSlider.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".MultiSlider\");\n  MultiSlider.Handle = MultiSliderHandle;\n  return MultiSlider;\n}(AbstractPureComponent2);\nexport { MultiSlider };\nfunction getLabelPrecision(_a) {\n  var labelPrecision = _a.labelPrecision,\n    _b = _a.stepSize,\n    stepSize = _b === void 0 ? MultiSlider.defaultSliderProps.stepSize : _b;\n  // infer default label precision from stepSize because that's how much the handle moves.\n  return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\nfunction getSortedInteractiveHandleProps(props) {\n  return getSortedHandleProps(props, function (childProps) {\n    return childProps.interactionKind !== HandleInteractionKind.NONE;\n  });\n}\nfunction getSortedHandleProps(_a, predicate) {\n  var children = _a.children;\n  if (predicate === void 0) {\n    predicate = function () {\n      return true;\n    };\n  }\n  var maybeHandles = React.Children.map(children, function (child) {\n    return Utils.isElementOfType(child, MultiSlider.Handle) && predicate(child.props) ? child.props : null;\n  });\n  var handles = maybeHandles != null ? maybeHandles : [];\n  handles = handles.filter(function (handle) {\n    return handle !== null;\n  });\n  handles.sort(function (left, right) {\n    return left.value - right.value;\n  });\n  return handles;\n}","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","Intent","Errors","DISPLAYNAME_PREFIX","Utils","Handle","HandleInteractionKind","HandleType","argMin","fillValues","formatPercentage","MultiSliderHandle","displayName","__extends","_this","labelPrecision","getLabelPrecision","props","tickSize","tickSizeRatio","ref","handleElements","push","event","canHandleTrackEvent","foundHandle","nearestHandleForValue","mouseEventClientOffset","beginHandleMovement","touchEventClientOffset","beginHandleTouchMovement","target","disabled","closest","SLIDER_HANDLE","index","callback","newValue","getNewHandleValues","newValues","handleProps","getSortedInteractiveHandleProps","oldValues","map","value","arraysEqual","onChange","forEach","handle","onRelease","MultiSlider","_a","stepSize","countDecimalPlaces","prevProps","prevHandleProps","newHandleProps","length","classes","SLIDER","DISABLED","labelRenderer","VERTICAL","vertical","className","onMouseDown","maybeHandleTrackClick","onTouchStart","maybeHandleTrackTouch","SLIDER_TRACK","trackElement","renderTracks","SLIDER_AXIS","renderLabels","renderHandles","updateTickSize","prevState","_super","componentDidUpdate","Error","SLIDER_ZERO_STEP","labelStepSize","undefined","labelValues","MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX","SLIDER_ZERO_LABEL_STEP","anyInvalidChildren","Children","children","child","isElementOfType","MULTISLIDER_INVALID_CHILD","isHandleTooltip","isFunction","toFixed","state","values","getLabelValues","max","min","labels","step","i","offsetPercentage","style","bottom","left","SLIDER_LABEL","key","formatLabel","trackStops","getSortedHandleProps","previous","handles","current","renderTrackFill","start","end","getOffsetRatio","sort","right","startRatio","endRatio","startOffset","endOffset","orientationStyle","top","trackStyleAfter","trackStyleBefore","SLIDER_PROGRESS","intentClass","getTrackIntent","type","htmlProps","_b","START","END","label","getHandlerForIndex","handleChange","handleRelease","addHandleRef","getOffset","offset","offsetValue","clientToValue","handleValue","Math","abs","oldIndex","slice","newIndex","indexOf","lockIndex","findFirstLockedHandleIndex","lockValue","startIndex","endIndex","inc","interactionKind","PUSH","approxEqual","clamp","showTrackFill","NONE","intentAfter","intentBefore","defaultTrackIntent","trackSize","clientHeight","clientWidth","setState","defaultSliderProps","predicate","maybeHandles","filter"],"sources":["/Users/mansidabriwal/Documents/Web design class/React-Assignment/react-app/node_modules/@blueprintjs/core/src/components/slider/multiSlider.tsx"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Intent } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, IntentProps, Props } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, HandleProps, HandleType } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n\n/**\n * SFC used to pass slider handle props to a `MultiSlider`.\n * This element is not rendered directly.\n */\nconst MultiSliderHandle: React.FC<HandleProps> = () => null;\nMultiSliderHandle.displayName = `${DISPLAYNAME_PREFIX}.MultiSliderHandle`;\n\nexport interface ISliderBaseProps extends Props, IntentProps {\n    children?: React.ReactNode;\n\n    /**\n     * Whether the slider is non-interactive.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Increment between successive labels. Must be greater than zero.\n     *\n     * @default inferred (if labelStepSize is undefined)\n     */\n    labelStepSize?: number;\n\n    /**\n     * Array of specific values for the label placement. This prop is mutually exclusive with\n     * `labelStepSize`.\n     */\n    labelValues?: readonly number[];\n\n    /**\n     * Number of decimal places to use when rendering label value. Default value is the number of\n     * decimals used in the `stepSize` prop. This prop has _no effect_ if you supply a custom\n     * `labelRenderer` callback.\n     *\n     * @default inferred from stepSize\n     */\n    labelPrecision?: number;\n\n    /**\n     * Maximum value of the slider.\n     *\n     * @default 10\n     */\n    max?: number;\n\n    /**\n     * Minimum value of the slider.\n     *\n     * @default 0\n     */\n    min?: number;\n\n    /**\n     * Whether a solid bar should be rendered on the track between current and initial values,\n     * or between handles for `RangeSlider`.\n     *\n     * @default true\n     */\n    showTrackFill?: boolean;\n\n    /**\n     * Increment between successive values; amount by which the handle moves. Must be greater than zero.\n     *\n     * @default 1\n     */\n    stepSize?: number;\n\n    /**\n     * Callback to render a single label. Useful for formatting numbers as currency or percentages.\n     * If `true`, labels will use number value formatted to `labelPrecision` decimal places.\n     * If `false`, labels will not be shown.\n     *\n     * The callback is provided a numeric value and optional rendering options, which include:\n     * - isHandleTooltip: whether this label is being rendered within a handle tooltip\n     *\n     * @default true\n     */\n    labelRenderer?: boolean | ((value: number, opts?: { isHandleTooltip: boolean }) => string | JSX.Element);\n\n    /**\n     * Whether to show the slider in a vertical orientation.\n     *\n     * @default false\n     */\n    vertical?: boolean;\n}\n\n// eslint-disable-next-line deprecation/deprecation\nexport type MultiSliderProps = IMultiSliderProps;\n/** @deprecated use MultiSliderProps */\nexport interface IMultiSliderProps extends ISliderBaseProps {\n    /** Default intent of a track segment, used only if no handle specifies `intentBefore/After`. */\n    defaultTrackIntent?: Intent;\n\n    /** Callback invoked when a handle value changes. Receives handle values in sorted order. */\n    onChange?(values: number[]): void;\n\n    /** Callback invoked when a handle is released. Receives handle values in sorted order. */\n    onRelease?(values: number[]): void;\n}\n\nexport interface ISliderState {\n    labelPrecision: number;\n    /** the client size, in pixels, of one tick */\n    tickSize: number;\n    /** the size of one tick as a ratio of the component's client size */\n    tickSizeRatio: number;\n}\n\nexport class MultiSlider extends AbstractPureComponent2<MultiSliderProps, ISliderState> {\n    public static defaultSliderProps: ISliderBaseProps = {\n        disabled: false,\n        max: 10,\n        min: 0,\n        showTrackFill: true,\n        stepSize: 1,\n        vertical: false,\n    };\n\n    public static defaultProps: MultiSliderProps = {\n        ...MultiSlider.defaultSliderProps,\n        defaultTrackIntent: Intent.NONE,\n    };\n\n    public static displayName = `${DISPLAYNAME_PREFIX}.MultiSlider`;\n\n    public static Handle = MultiSliderHandle;\n\n    public static getDerivedStateFromProps(props: MultiSliderProps) {\n        return { labelPrecision: MultiSlider.getLabelPrecision(props) };\n    }\n\n    private static getLabelPrecision({ labelPrecision, stepSize }: MultiSliderProps) {\n        // infer default label precision from stepSize because that's how much the handle moves.\n        return labelPrecision == null ? Utils.countDecimalPlaces(stepSize!) : labelPrecision;\n    }\n\n    public state: ISliderState = {\n        labelPrecision: getLabelPrecision(this.props),\n        tickSize: 0,\n        tickSizeRatio: 0,\n    };\n\n    private handleElements: Handle[] = [];\n\n    private trackElement: HTMLElement | null = null;\n\n    public getSnapshotBeforeUpdate(prevProps: MultiSliderProps): null {\n        const prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n        const newHandleProps = getSortedInteractiveHandleProps(this.props);\n        if (newHandleProps.length !== prevHandleProps.length) {\n            // clear refs\n            this.handleElements = [];\n        }\n        return null;\n    }\n\n    public render() {\n        const classes = classNames(\n            Classes.SLIDER,\n            {\n                [Classes.DISABLED]: this.props.disabled,\n                [`${Classes.SLIDER}-unlabeled`]: this.props.labelRenderer === false,\n                [Classes.VERTICAL]: this.props.vertical,\n            },\n            this.props.className,\n        );\n        return (\n            <div className={classes} onMouseDown={this.maybeHandleTrackClick} onTouchStart={this.maybeHandleTrackTouch}>\n                <div className={Classes.SLIDER_TRACK} ref={ref => (this.trackElement = ref)}>\n                    {this.renderTracks()}\n                </div>\n                <div className={Classes.SLIDER_AXIS}>{this.renderLabels()}</div>\n                {this.renderHandles()}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateTickSize();\n    }\n\n    public componentDidUpdate(prevProps: MultiSliderProps, prevState: ISliderState) {\n        super.componentDidUpdate(prevProps, prevState);\n        this.updateTickSize();\n    }\n\n    protected validateProps(props: React.PropsWithChildren<MultiSliderProps>) {\n        if (props.stepSize! <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_STEP);\n        }\n        if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n            throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n        }\n        if (props.labelStepSize !== undefined && props.labelStepSize! <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n        }\n\n        let anyInvalidChildren = false;\n        React.Children.forEach(props.children, child => {\n            // allow boolean coercion to omit nulls and false values\n            if (child && !Utils.isElementOfType(child, MultiSlider.Handle)) {\n                anyInvalidChildren = true;\n            }\n        });\n        if (anyInvalidChildren) {\n            throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n        }\n    }\n\n    private formatLabel(value: number, isHandleTooltip: boolean = false) {\n        const { labelRenderer } = this.props;\n        if (labelRenderer === false) {\n            return undefined;\n        } else if (Utils.isFunction(labelRenderer)) {\n            return labelRenderer(value, { isHandleTooltip });\n        } else {\n            return value.toFixed(this.state.labelPrecision);\n        }\n    }\n\n    private renderLabels() {\n        if (this.props.labelRenderer === false) {\n            return null;\n        }\n\n        const values = this.getLabelValues();\n        const { max, min } = this.props;\n        const labels = values.map((step, i) => {\n            const offsetPercentage = formatPercentage((step - min!) / (max! - min!));\n            const style = this.props.vertical ? { bottom: offsetPercentage } : { left: offsetPercentage };\n            return (\n                <div className={Classes.SLIDER_LABEL} key={i} style={style}>\n                    {this.formatLabel(step)}\n                </div>\n            );\n        });\n\n        return labels;\n    }\n\n    private renderTracks() {\n        const trackStops = getSortedHandleProps(this.props);\n        trackStops.push({ value: this.props.max! });\n\n        // render from current to previous, then increment previous\n        let previous: HandleProps = { value: this.props.min! };\n        const handles: JSX.Element[] = [];\n        for (let index = 0; index < trackStops.length; index++) {\n            const current = trackStops[index];\n            handles.push(this.renderTrackFill(index, previous, current));\n            previous = current;\n        }\n        return handles;\n    }\n\n    private renderTrackFill(index: number, start: HandleProps, end: HandleProps) {\n        // ensure startRatio <= endRatio\n        const [startRatio, endRatio] = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(\n            (left, right) => left - right,\n        );\n        const startOffset = formatPercentage(startRatio);\n        const endOffset = formatPercentage(1 - endRatio);\n        const orientationStyle: React.CSSProperties = this.props.vertical\n            ? { bottom: startOffset, top: endOffset, left: 0 }\n            : { left: startOffset, right: endOffset, top: 0 };\n\n        const style: React.CSSProperties = {\n            ...orientationStyle,\n            ...(start.trackStyleAfter || end.trackStyleBefore || {}),\n        };\n\n        const classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n        return <div key={`track-${index}`} className={classes} style={style} />;\n    }\n\n    private renderHandles() {\n        const { disabled, max, min, stepSize, vertical } = this.props;\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n\n        if (handleProps.length === 0) {\n            return null;\n        }\n\n        return handleProps.map(({ value, type, className, htmlProps }, index) => (\n            <Handle\n                htmlProps={htmlProps}\n                className={classNames(\n                    {\n                        [Classes.START]: type === HandleType.START,\n                        [Classes.END]: type === HandleType.END,\n                    },\n                    className,\n                )}\n                disabled={disabled}\n                key={`${index}-${handleProps.length}`}\n                label={this.formatLabel(value, true)}\n                max={max!}\n                min={min!}\n                onChange={this.getHandlerForIndex(index, this.handleChange)}\n                onRelease={this.getHandlerForIndex(index, this.handleRelease)}\n                ref={this.addHandleRef}\n                stepSize={stepSize!}\n                tickSize={this.state.tickSize}\n                tickSizeRatio={this.state.tickSizeRatio}\n                value={value}\n                vertical={vertical!}\n            />\n        ));\n    }\n\n    private addHandleRef = (ref: Handle) => {\n        if (ref != null) {\n            this.handleElements.push(ref);\n        }\n    };\n\n    private maybeHandleTrackClick = (event: React.MouseEvent<HTMLDivElement>) => {\n        if (this.canHandleTrackEvent(event)) {\n            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>\n                handle.mouseEventClientOffset(event),\n            );\n            if (foundHandle) {\n                foundHandle.beginHandleMovement(event);\n            }\n        }\n    };\n\n    private maybeHandleTrackTouch = (event: React.TouchEvent<HTMLDivElement>) => {\n        if (this.canHandleTrackEvent(event)) {\n            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>\n                handle.touchEventClientOffset(event),\n            );\n            if (foundHandle) {\n                foundHandle.beginHandleTouchMovement(event);\n            }\n        }\n    };\n\n    private canHandleTrackEvent = (event: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {\n        const target = event.target as HTMLElement;\n        // ensure event does not come from inside the handle\n        return !this.props.disabled && target.closest(`.${Classes.SLIDER_HANDLE}`) == null;\n    };\n\n    private nearestHandleForValue(handles: Handle[], getOffset: (handle: Handle) => number): Handle | undefined {\n        return argMin(handles, handle => {\n            const offset = getOffset(handle);\n            const offsetValue = handle.clientToValue(offset);\n            const handleValue = handle.props.value!;\n            return Math.abs(offsetValue - handleValue);\n        });\n    }\n\n    private getHandlerForIndex = (index: number, callback?: (values: number[]) => void) => {\n        return (newValue: number) => {\n            callback?.(this.getNewHandleValues(newValue, index));\n        };\n    };\n\n    private getNewHandleValues(newValue: number, oldIndex: number) {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        const oldValues = handleProps.map(handle => handle.value);\n        const newValues = oldValues.slice();\n        newValues[oldIndex] = newValue;\n        newValues.sort((left, right) => left - right);\n\n        const newIndex = newValues.indexOf(newValue);\n        const lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n        if (lockIndex === -1) {\n            fillValues(newValues, oldIndex, newIndex, newValue);\n        } else {\n            // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n            const lockValue = oldValues[lockIndex];\n            fillValues(oldValues, oldIndex, lockIndex, lockValue);\n            return oldValues;\n        }\n\n        return newValues;\n    }\n\n    private findFirstLockedHandleIndex(startIndex: number, endIndex: number): number {\n        const inc = startIndex < endIndex ? 1 : -1;\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n\n        for (let index = startIndex + inc; index !== endIndex + inc; index += inc) {\n            if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n                return index;\n            }\n        }\n\n        return -1;\n    }\n\n    private handleChange = (newValues: number[]) => {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        const oldValues = handleProps.map(handle => handle.value);\n        if (!Utils.arraysEqual(newValues, oldValues)) {\n            this.props.onChange?.(newValues);\n            handleProps.forEach((handle, index) => {\n                if (oldValues[index] !== newValues[index]) {\n                    handle.onChange?.(newValues[index]);\n                }\n            });\n        }\n    };\n\n    private handleRelease = (newValues: number[]) => {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        this.props.onRelease?.(newValues);\n        handleProps.forEach((handle, index) => {\n            handle.onRelease?.(newValues[index]);\n        });\n    };\n\n    private getLabelValues() {\n        const { labelStepSize, labelValues, min, max } = this.props;\n        let values: number[] = [];\n        if (labelValues !== undefined) {\n            values = labelValues.slice();\n        } else {\n            for (let i = min!; i < max! || Utils.approxEqual(i, max!); i += labelStepSize ?? 1) {\n                values.push(i);\n            }\n        }\n\n        return values;\n    }\n\n    private getOffsetRatio(value: number) {\n        return Utils.clamp((value - this.props.min!) * this.state.tickSizeRatio, 0, 1);\n    }\n\n    private getTrackIntent(start: HandleProps, end?: HandleProps): Intent {\n        if (!this.props.showTrackFill) {\n            return Intent.NONE;\n        }\n        if (start.intentAfter !== undefined) {\n            return start.intentAfter;\n        } else if (end !== undefined && end.intentBefore !== undefined) {\n            return end.intentBefore;\n        }\n        return this.props.defaultTrackIntent!;\n    }\n\n    private updateTickSize() {\n        if (this.trackElement != null) {\n            const trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n            const tickSizeRatio = 1 / ((this.props.max as number) - (this.props.min as number));\n            const tickSize = trackSize * tickSizeRatio;\n            this.setState({ tickSize, tickSizeRatio });\n        }\n    }\n}\n\nfunction getLabelPrecision({ labelPrecision, stepSize = MultiSlider.defaultSliderProps.stepSize! }: MultiSliderProps) {\n    // infer default label precision from stepSize because that's how much the handle moves.\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\n\nfunction getSortedInteractiveHandleProps(props: React.PropsWithChildren<MultiSliderProps>): HandleProps[] {\n    return getSortedHandleProps(props, childProps => childProps.interactionKind !== HandleInteractionKind.NONE);\n}\n\nfunction getSortedHandleProps({ children }: MultiSliderProps, predicate: (props: HandleProps) => boolean = () => true) {\n    const maybeHandles = React.Children.map(children, child =>\n        Utils.isElementOfType(child, MultiSlider.Handle) && predicate(child.props) ? child.props : null,\n    );\n    let handles = maybeHandles != null ? maybeHandles : [];\n    handles = handles.filter(handle => handle !== null);\n    handles.sort((left, right) => left.value - right.value);\n    return handles;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}