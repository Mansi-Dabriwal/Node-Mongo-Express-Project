{"ast":null,"code":"/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Tab } from \"./tab\";\nimport { generateTabPanelId, generateTabTitleId, TabTitle } from \"./tabTitle\";\nexport var Expander = function () {\n  return React.createElement(\"div\", {\n    className: Classes.FLEX_EXPANDER\n  });\n};\nvar TAB_SELECTOR = \".\".concat(Classes.TAB);\nvar Tabs = /** @class */function (_super) {\n  __extends(Tabs, _super);\n  function Tabs(props) {\n    var _this = _super.call(this, props) || this;\n    _this.tablistElement = null;\n    _this.refHandlers = {\n      tablist: function (tabElement) {\n        return _this.tablistElement = tabElement;\n      }\n    };\n    _this.handleKeyDown = function (e) {\n      var _a;\n      var focusedElement = (_a = Utils.getActiveElement(_this.tablistElement)) === null || _a === void 0 ? void 0 : _a.closest(TAB_SELECTOR);\n      // rest of this is potentially expensive and futile, so bail if no tab is focused\n      if (focusedElement == null) {\n        return;\n      }\n      // must rely on DOM state because we have no way of mapping `focusedElement` to a JSX.Element\n      var enabledTabElements = _this.getTabElements().filter(function (el) {\n        return el.getAttribute(\"aria-disabled\") === \"false\";\n      });\n      var focusedIndex = enabledTabElements.indexOf(focusedElement);\n      var direction = _this.getKeyCodeDirection(e);\n      if (focusedIndex >= 0 && direction !== undefined) {\n        e.preventDefault();\n        var length_1 = enabledTabElements.length;\n        // auto-wrapping at 0 and `length`\n        var nextFocusedIndex = (focusedIndex + direction + length_1) % length_1;\n        enabledTabElements[nextFocusedIndex].focus();\n      }\n    };\n    _this.handleKeyPress = function (e) {\n      var targetTabElement = e.target.closest(TAB_SELECTOR);\n      // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n      // eslint-disable-next-line deprecation/deprecation\n      if (targetTabElement != null && Keys.isKeyboardClick(e.which)) {\n        e.preventDefault();\n        targetTabElement.click();\n      }\n    };\n    _this.handleTabClick = function (newTabId, event) {\n      var _a, _b;\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newTabId, _this.state.selectedTabId, event);\n      if (_this.props.selectedTabId === undefined) {\n        _this.setState({\n          selectedTabId: newTabId\n        });\n      }\n    };\n    _this.renderTabPanel = function (tab) {\n      var _a = tab.props,\n        className = _a.className,\n        panel = _a.panel,\n        id = _a.id,\n        panelClassName = _a.panelClassName;\n      if (panel === undefined) {\n        return undefined;\n      }\n      return React.createElement(\"div\", {\n        \"aria-labelledby\": generateTabTitleId(_this.props.id, id),\n        \"aria-hidden\": id !== _this.state.selectedTabId,\n        className: classNames(Classes.TAB_PANEL, className, panelClassName),\n        id: generateTabPanelId(_this.props.id, id),\n        key: id,\n        role: \"tabpanel\"\n      }, panel);\n    };\n    _this.renderTabTitle = function (child) {\n      if (isTabElement(child)) {\n        var id = child.props.id;\n        return React.createElement(TabTitle, __assign({}, child.props, {\n          parentId: _this.props.id,\n          onClick: _this.handleTabClick,\n          selected: id === _this.state.selectedTabId\n        }));\n      }\n      return child;\n    };\n    var selectedTabId = _this.getInitialSelectedTabId();\n    _this.state = {\n      selectedTabId: selectedTabId\n    };\n    return _this;\n  }\n  Tabs.getDerivedStateFromProps = function (_a) {\n    var selectedTabId = _a.selectedTabId;\n    if (selectedTabId !== undefined) {\n      // keep state in sync with controlled prop, so state is canonical source of truth\n      return {\n        selectedTabId: selectedTabId\n      };\n    }\n    return null;\n  };\n  Tabs.prototype.render = function () {\n    var _a, _b;\n    var _c = this.state,\n      indicatorWrapperStyle = _c.indicatorWrapperStyle,\n      selectedTabId = _c.selectedTabId;\n    var tabTitles = React.Children.map(this.props.children, this.renderTabTitle);\n    var tabPanels = this.getTabChildren().filter(this.props.renderActiveTabPanelOnly ? function (tab) {\n      return tab.props.id === selectedTabId;\n    } : function () {\n      return true;\n    }).map(this.renderTabPanel);\n    var tabIndicator = this.props.animate ? React.createElement(\"div\", {\n      className: Classes.TAB_INDICATOR_WRAPPER,\n      style: indicatorWrapperStyle\n    }, React.createElement(\"div\", {\n      className: Classes.TAB_INDICATOR\n    })) : null;\n    var classes = classNames(Classes.TABS, (_a = {}, _a[Classes.VERTICAL] = this.props.vertical, _a), this.props.className);\n    var tabListClasses = classNames(Classes.TAB_LIST, (_b = {}, _b[Classes.LARGE] = this.props.large, _b));\n    return React.createElement(\"div\", {\n      className: classes\n    }, React.createElement(\"div\", {\n      className: tabListClasses,\n      onKeyDown: this.handleKeyDown,\n      onKeyPress: this.handleKeyPress,\n      ref: this.refHandlers.tablist,\n      role: \"tablist\"\n    }, tabIndicator, tabTitles), tabPanels);\n  };\n  Tabs.prototype.componentDidMount = function () {\n    this.moveSelectionIndicator(false);\n  };\n  Tabs.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (this.state.selectedTabId !== prevState.selectedTabId) {\n      this.moveSelectionIndicator();\n    } else if (prevState.selectedTabId != null) {\n      // comparing React nodes is difficult to do with simple logic, so\n      // shallowly compare just their props as a workaround.\n      var didChildrenChange = !Utils.arraysEqual(this.getTabChildrenProps(prevProps), this.getTabChildrenProps(), Utils.shallowCompareKeys);\n      if (didChildrenChange) {\n        this.moveSelectionIndicator();\n      }\n    }\n  };\n  Tabs.prototype.getInitialSelectedTabId = function () {\n    // NOTE: providing an unknown ID will hide the selection\n    var _a = this.props,\n      defaultSelectedTabId = _a.defaultSelectedTabId,\n      selectedTabId = _a.selectedTabId;\n    if (selectedTabId !== undefined) {\n      return selectedTabId;\n    } else if (defaultSelectedTabId !== undefined) {\n      return defaultSelectedTabId;\n    } else {\n      // select first tab in absence of user input\n      var tabs = this.getTabChildren();\n      return tabs.length === 0 ? undefined : tabs[0].props.id;\n    }\n  };\n  Tabs.prototype.getKeyCodeDirection = function (e) {\n    if (isEventKeyCode(e, Keys.ARROW_LEFT, Keys.ARROW_UP)) {\n      return -1;\n    } else if (isEventKeyCode(e, Keys.ARROW_RIGHT, Keys.ARROW_DOWN)) {\n      return 1;\n    }\n    return undefined;\n  };\n  Tabs.prototype.getTabChildrenProps = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n    return this.getTabChildren(props).map(function (child) {\n      return child.props;\n    });\n  };\n  /** Filters children to only `<Tab>`s */\n  Tabs.prototype.getTabChildren = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n    return React.Children.toArray(props.children).filter(isTabElement);\n  };\n  /** Queries root HTML element for all tabs with optional filter selector */\n  Tabs.prototype.getTabElements = function (subselector) {\n    if (subselector === void 0) {\n      subselector = \"\";\n    }\n    if (this.tablistElement == null) {\n      return [];\n    }\n    return Array.from(this.tablistElement.querySelectorAll(TAB_SELECTOR + subselector));\n  };\n  /**\n   * Calculate the new height, width, and position of the tab indicator.\n   * Store the CSS values so the transition animation can start.\n   */\n  Tabs.prototype.moveSelectionIndicator = function (animate) {\n    if (animate === void 0) {\n      animate = true;\n    }\n    if (this.tablistElement == null || !this.props.animate) {\n      return;\n    }\n    var tabIdSelector = \"\".concat(TAB_SELECTOR, \"[data-tab-id=\\\"\").concat(this.state.selectedTabId, \"\\\"]\");\n    var selectedTabElement = this.tablistElement.querySelector(tabIdSelector);\n    var indicatorWrapperStyle = {\n      display: \"none\"\n    };\n    if (selectedTabElement != null) {\n      var clientHeight = selectedTabElement.clientHeight,\n        clientWidth = selectedTabElement.clientWidth,\n        offsetLeft = selectedTabElement.offsetLeft,\n        offsetTop = selectedTabElement.offsetTop;\n      indicatorWrapperStyle = {\n        height: clientHeight,\n        transform: \"translateX(\".concat(Math.floor(offsetLeft), \"px) translateY(\").concat(Math.floor(offsetTop), \"px)\"),\n        width: clientWidth\n      };\n      if (!animate) {\n        indicatorWrapperStyle.transition = \"none\";\n      }\n    }\n    this.setState({\n      indicatorWrapperStyle: indicatorWrapperStyle\n    });\n  };\n  /** Insert a `Tabs.Expander` between any two children to right-align all subsequent children. */\n  Tabs.Expander = Expander;\n  Tabs.Tab = Tab;\n  Tabs.defaultProps = {\n    animate: true,\n    large: false,\n    renderActiveTabPanelOnly: false,\n    vertical: false\n  };\n  Tabs.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Tabs\");\n  return Tabs;\n}(AbstractPureComponent2);\nexport { Tabs };\nfunction isEventKeyCode(e) {\n  var codes = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    codes[_i - 1] = arguments[_i];\n  }\n  // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n  // eslint-disable-next-line deprecation/deprecation\n  return codes.indexOf(e.which) >= 0;\n}\nfunction isTabElement(child) {\n  return Utils.isElementOfType(child, Tab);\n}","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","Keys","DISPLAYNAME_PREFIX","Utils","Tab","generateTabPanelId","generateTabTitleId","TabTitle","Expander","className","FLEX_EXPANDER","TAB_SELECTOR","TAB","__extends","props","_super","_this","tablist","tabElement","tablistElement","e","focusedElement","getActiveElement","closest","enabledTabElements","getTabElements","filter","getAttribute","focusedIndex","indexOf","direction","getKeyCodeDirection","undefined","preventDefault","nextFocusedIndex","length_1","focus","targetTabElement","target","isKeyboardClick","which","click","newTabId","event","onChange","state","selectedTabId","setState","tab","panel","id","panelClassName","TAB_PANEL","key","role","child","isTabElement","parentId","onClick","handleTabClick","selected","getInitialSelectedTabId","Tabs","_a","indicatorWrapperStyle","tabTitles","Children","map","children","renderTabTitle","tabPanels","getTabChildren","renderActiveTabPanelOnly","renderTabPanel","tabIndicator","animate","TAB_INDICATOR_WRAPPER","style","TAB_INDICATOR","classes","TABS","VERTICAL","vertical","tabListClasses","TAB_LIST","_b","LARGE","large","onKeyDown","handleKeyDown","onKeyPress","handleKeyPress","ref","refHandlers","moveSelectionIndicator","prevProps","prevState","didChildrenChange","arraysEqual","getTabChildrenProps","shallowCompareKeys","defaultSelectedTabId","tabs","length","isEventKeyCode","ARROW_LEFT","ARROW_UP","ARROW_RIGHT","ARROW_DOWN","toArray","subselector","Array","from","querySelectorAll","tabIdSelector","selectedTabElement","querySelector","display","clientWidth","offsetLeft","offsetTop","height","clientHeight","transform","Math","floor","width","transition","_i","codes","isElementOfType"],"sources":["/Users/mansidabriwal/Documents/Web design class/React-Assignment/react-app/node_modules/@blueprintjs/core/src/components/tabs/tabs.tsx"],"sourcesContent":["/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX, Props } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Tab, TabId, TabProps } from \"./tab\";\nimport { generateTabPanelId, generateTabTitleId, TabTitle } from \"./tabTitle\";\n\nexport const Expander: React.FC = () => <div className={Classes.FLEX_EXPANDER} />;\n\ntype TabElement = React.ReactElement<TabProps & { children: React.ReactNode }>;\n\nconst TAB_SELECTOR = `.${Classes.TAB}`;\n\n// eslint-disable-next-line deprecation/deprecation\nexport type TabsProps = ITabsProps;\n/** @deprecated use TabsProps */\nexport interface ITabsProps extends Props {\n    /**\n     * Whether the selected tab indicator should animate its movement.\n     *\n     * @default true\n     */\n    animate?: boolean;\n\n    /** Tab elements. */\n    children?: React.ReactNode;\n\n    /**\n     * Initial selected tab `id`, for uncontrolled usage.\n     * Note that this prop refers only to `<Tab>` children; other types of elements are ignored.\n     *\n     * @default first tab\n     */\n    defaultSelectedTabId?: TabId;\n\n    /**\n     * Unique identifier for this `Tabs` container. This will be combined with the `id` of each\n     * `Tab` child to generate ARIA accessibility attributes. IDs are required and should be\n     * unique on the page to support server-side rendering.\n     */\n    id: TabId;\n\n    /**\n     * If set to `true`, the tab titles will display with larger styling.\n     * This will apply large styles only to the tabs at this level, not to nested tabs.\n     *\n     * @default false\n     */\n    large?: boolean;\n\n    /**\n     * Whether inactive tab panels should be removed from the DOM and unmounted in React.\n     * This can be a performance enhancement when rendering many complex panels, but requires\n     * careful support for unmounting and remounting.\n     *\n     * @default false\n     */\n    renderActiveTabPanelOnly?: boolean;\n\n    /**\n     * Selected tab `id`, for controlled usage.\n     * Providing this prop will put the component in controlled mode.\n     * Unknown ids will result in empty selection (no errors).\n     */\n    selectedTabId?: TabId;\n\n    /**\n     * Whether to show tabs stacked vertically on the left side.\n     *\n     * @default false\n     */\n    vertical?: boolean;\n\n    /**\n     * A callback function that is invoked when a tab in the tab list is clicked.\n     */\n    onChange?(newTabId: TabId, prevTabId: TabId | undefined, event: React.MouseEvent<HTMLElement>): void;\n}\n\nexport interface ITabsState {\n    indicatorWrapperStyle?: React.CSSProperties;\n    selectedTabId?: TabId;\n}\n\nexport class Tabs extends AbstractPureComponent2<TabsProps, ITabsState> {\n    /** Insert a `Tabs.Expander` between any two children to right-align all subsequent children. */\n    public static Expander = Expander;\n\n    public static Tab = Tab;\n\n    public static defaultProps: Partial<TabsProps> = {\n        animate: true,\n        large: false,\n        renderActiveTabPanelOnly: false,\n        vertical: false,\n    };\n\n    public static displayName = `${DISPLAYNAME_PREFIX}.Tabs`;\n\n    public static getDerivedStateFromProps({ selectedTabId }: TabsProps) {\n        if (selectedTabId !== undefined) {\n            // keep state in sync with controlled prop, so state is canonical source of truth\n            return { selectedTabId };\n        }\n        return null;\n    }\n\n    private tablistElement: HTMLDivElement | null = null;\n\n    private refHandlers = {\n        tablist: (tabElement: HTMLDivElement) => (this.tablistElement = tabElement),\n    };\n\n    constructor(props: TabsProps) {\n        super(props);\n        const selectedTabId = this.getInitialSelectedTabId();\n        this.state = { selectedTabId };\n    }\n\n    public render() {\n        const { indicatorWrapperStyle, selectedTabId } = this.state;\n\n        const tabTitles = React.Children.map(this.props.children, this.renderTabTitle);\n\n        const tabPanels = this.getTabChildren()\n            .filter(this.props.renderActiveTabPanelOnly ? tab => tab.props.id === selectedTabId : () => true)\n            .map(this.renderTabPanel);\n\n        const tabIndicator = this.props.animate ? (\n            <div className={Classes.TAB_INDICATOR_WRAPPER} style={indicatorWrapperStyle}>\n                <div className={Classes.TAB_INDICATOR} />\n            </div>\n        ) : null;\n\n        const classes = classNames(Classes.TABS, { [Classes.VERTICAL]: this.props.vertical }, this.props.className);\n        const tabListClasses = classNames(Classes.TAB_LIST, {\n            [Classes.LARGE]: this.props.large,\n        });\n\n        return (\n            <div className={classes}>\n                <div\n                    className={tabListClasses}\n                    onKeyDown={this.handleKeyDown}\n                    onKeyPress={this.handleKeyPress}\n                    ref={this.refHandlers.tablist}\n                    role=\"tablist\"\n                >\n                    {tabIndicator}\n                    {tabTitles}\n                </div>\n                {tabPanels}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.moveSelectionIndicator(false);\n    }\n\n    public componentDidUpdate(prevProps: TabsProps, prevState: ITabsState) {\n        if (this.state.selectedTabId !== prevState.selectedTabId) {\n            this.moveSelectionIndicator();\n        } else if (prevState.selectedTabId != null) {\n            // comparing React nodes is difficult to do with simple logic, so\n            // shallowly compare just their props as a workaround.\n            const didChildrenChange = !Utils.arraysEqual(\n                this.getTabChildrenProps(prevProps),\n                this.getTabChildrenProps(),\n                Utils.shallowCompareKeys,\n            );\n            if (didChildrenChange) {\n                this.moveSelectionIndicator();\n            }\n        }\n    }\n\n    private getInitialSelectedTabId() {\n        // NOTE: providing an unknown ID will hide the selection\n        const { defaultSelectedTabId, selectedTabId } = this.props;\n        if (selectedTabId !== undefined) {\n            return selectedTabId;\n        } else if (defaultSelectedTabId !== undefined) {\n            return defaultSelectedTabId;\n        } else {\n            // select first tab in absence of user input\n            const tabs = this.getTabChildren();\n            return tabs.length === 0 ? undefined : tabs[0].props.id;\n        }\n    }\n\n    private getKeyCodeDirection(e: React.KeyboardEvent<HTMLElement>) {\n        if (isEventKeyCode(e, Keys.ARROW_LEFT, Keys.ARROW_UP)) {\n            return -1;\n        } else if (isEventKeyCode(e, Keys.ARROW_RIGHT, Keys.ARROW_DOWN)) {\n            return 1;\n        }\n        return undefined;\n    }\n\n    private getTabChildrenProps(props: TabsProps & { children?: React.ReactNode } = this.props) {\n        return this.getTabChildren(props).map(child => child.props);\n    }\n\n    /** Filters children to only `<Tab>`s */\n    private getTabChildren(props: TabsProps & { children?: React.ReactNode } = this.props) {\n        return React.Children.toArray(props.children).filter(isTabElement);\n    }\n\n    /** Queries root HTML element for all tabs with optional filter selector */\n    private getTabElements(subselector = \"\") {\n        if (this.tablistElement == null) {\n            return [];\n        }\n        return Array.from(this.tablistElement.querySelectorAll(TAB_SELECTOR + subselector));\n    }\n\n    private handleKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        const focusedElement = Utils.getActiveElement(this.tablistElement)?.closest(TAB_SELECTOR);\n        // rest of this is potentially expensive and futile, so bail if no tab is focused\n        if (focusedElement == null) {\n            return;\n        }\n\n        // must rely on DOM state because we have no way of mapping `focusedElement` to a JSX.Element\n        const enabledTabElements = this.getTabElements().filter(el => el.getAttribute(\"aria-disabled\") === \"false\");\n        const focusedIndex = enabledTabElements.indexOf(focusedElement);\n        const direction = this.getKeyCodeDirection(e);\n\n        if (focusedIndex >= 0 && direction !== undefined) {\n            e.preventDefault();\n            const { length } = enabledTabElements;\n            // auto-wrapping at 0 and `length`\n            const nextFocusedIndex = (focusedIndex + direction + length) % length;\n            (enabledTabElements[nextFocusedIndex] as HTMLElement).focus();\n        }\n    };\n\n    private handleKeyPress = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        const targetTabElement = (e.target as HTMLElement).closest(TAB_SELECTOR) as HTMLElement;\n        // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        // eslint-disable-next-line deprecation/deprecation\n        if (targetTabElement != null && Keys.isKeyboardClick(e.which)) {\n            e.preventDefault();\n            targetTabElement.click();\n        }\n    };\n\n    private handleTabClick = (newTabId: TabId, event: React.MouseEvent<HTMLElement>) => {\n        this.props.onChange?.(newTabId, this.state.selectedTabId, event);\n        if (this.props.selectedTabId === undefined) {\n            this.setState({ selectedTabId: newTabId });\n        }\n    };\n\n    /**\n     * Calculate the new height, width, and position of the tab indicator.\n     * Store the CSS values so the transition animation can start.\n     */\n    private moveSelectionIndicator(animate = true) {\n        if (this.tablistElement == null || !this.props.animate) {\n            return;\n        }\n\n        const tabIdSelector = `${TAB_SELECTOR}[data-tab-id=\"${this.state.selectedTabId}\"]`;\n        const selectedTabElement = this.tablistElement.querySelector(tabIdSelector) as HTMLElement;\n\n        let indicatorWrapperStyle: React.CSSProperties = { display: \"none\" };\n        if (selectedTabElement != null) {\n            const { clientHeight, clientWidth, offsetLeft, offsetTop } = selectedTabElement;\n            indicatorWrapperStyle = {\n                height: clientHeight,\n                transform: `translateX(${Math.floor(offsetLeft)}px) translateY(${Math.floor(offsetTop)}px)`,\n                width: clientWidth,\n            };\n\n            if (!animate) {\n                indicatorWrapperStyle.transition = \"none\";\n            }\n        }\n        this.setState({ indicatorWrapperStyle });\n    }\n\n    private renderTabPanel = (tab: TabElement) => {\n        const { className, panel, id, panelClassName } = tab.props;\n        if (panel === undefined) {\n            return undefined;\n        }\n        return (\n            <div\n                aria-labelledby={generateTabTitleId(this.props.id, id)}\n                aria-hidden={id !== this.state.selectedTabId}\n                className={classNames(Classes.TAB_PANEL, className, panelClassName)}\n                id={generateTabPanelId(this.props.id, id)}\n                key={id}\n                role=\"tabpanel\"\n            >\n                {panel}\n            </div>\n        );\n    };\n\n    private renderTabTitle = (child: React.ReactNode) => {\n        if (isTabElement(child)) {\n            const { id } = child.props;\n            return (\n                <TabTitle\n                    {...child.props}\n                    parentId={this.props.id}\n                    onClick={this.handleTabClick}\n                    selected={id === this.state.selectedTabId}\n                />\n            );\n        }\n        return child;\n    };\n}\n\nfunction isEventKeyCode(e: React.KeyboardEvent<HTMLElement>, ...codes: number[]) {\n    // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n    // eslint-disable-next-line deprecation/deprecation\n    return codes.indexOf(e.which) >= 0;\n}\n\nfunction isTabElement(child: any): child is TabElement {\n    return Utils.isElementOfType(child, Tab);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}