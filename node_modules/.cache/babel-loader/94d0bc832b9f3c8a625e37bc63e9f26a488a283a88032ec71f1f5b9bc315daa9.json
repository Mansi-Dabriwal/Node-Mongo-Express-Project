{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent2, Classes, refHandler, setRef } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Overlay } from \"../overlay/overlay\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverMigrationUtils\";\nimport { arrowOffsetModifier, getTransformOrigin } from \"./popperUtils\";\nexport var PopoverInteractionKind = {\n  CLICK: \"click\",\n  CLICK_TARGET_ONLY: \"click-target\",\n  HOVER: \"hover\",\n  HOVER_TARGET_ONLY: \"hover-target\"\n};\n/** @deprecated use { Popover2 } from \"@blueprintjs/popover2\" */\n// eslint-disable-next-line deprecation/deprecation\nvar Popover = /** @class */function (_super) {\n  __extends(Popover, _super);\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.popoverRef = React.createRef();\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     */\n    _this.popoverElement = null;\n    /** DOM element that contains the target. */\n    _this.targetElement = null;\n    _this.state = {\n      hasDarkParent: false,\n      isOpen: _this.getIsOpen(_this.props),\n      transformOrigin: \"\"\n    };\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    _this.isMouseInTargetOrPopover = false;\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    _this.lostFocusOnSamePage = true;\n    _this.handlePopoverRef = refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n    _this.handleTargetRef = function (ref) {\n      return _this.targetElement = ref;\n    };\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    _this.reposition = function () {\n      var _a;\n      return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this);\n    };\n    _this.renderPopover = function (popperProps) {\n      var _a;\n      var _b = _this.props,\n        interactionKind = _b.interactionKind,\n        usePortal = _b.usePortal;\n      var transformOrigin = _this.state.transformOrigin;\n      // Need to update our reference to this on every render as it will change.\n      _this.popperScheduleUpdate = popperProps.scheduleUpdate;\n      var popoverHandlers = {\n        // always check popover clicks for dismiss class\n        onClick: _this.handlePopoverClick\n      };\n      if (interactionKind === PopoverInteractionKind.HOVER || !usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY) {\n        popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n        popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n      }\n      var popoverClasses = classNames(Classes.POPOVER, (_a = {}, _a[Classes.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent, _a[Classes.MINIMAL] = _this.props.minimal, _a[Classes.POPOVER_CAPTURING_DISMISS] = _this.props.captureDismiss, _a[Classes.POPOVER_OUT_OF_BOUNDARIES] = popperProps.outOfBoundaries === true, _a), _this.props.popoverClassName);\n      return React.createElement(\"div\", {\n        className: Classes.TRANSITION_CONTAINER,\n        ref: popperProps.ref,\n        style: popperProps.style\n      }, React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, React.createElement(\"div\", __assign({\n        className: popoverClasses,\n        style: {\n          transformOrigin: transformOrigin\n        },\n        ref: _this.popoverRef\n      }, popoverHandlers), _this.isArrowEnabled() && React.createElement(PopoverArrow, {\n        arrowProps: popperProps.arrowProps,\n        placement: popperProps.placement\n      }), React.createElement(\"div\", {\n        className: Classes.POPOVER_CONTENT\n      }, _this.understandChildren().content))));\n    };\n    _this.renderTarget = function (referenceProps) {\n      var _a, _b;\n      var _c = _this.props,\n        fill = _c.fill,\n        openOnTargetFocus = _c.openOnTargetFocus,\n        targetClassName = _c.targetClassName,\n        _d = _c.targetProps,\n        targetProps = _d === void 0 ? {} : _d;\n      var isOpen = _this.state.isOpen;\n      var isControlled = _this.isControlled();\n      var isHoverInteractionKind = _this.isHoverInteractionKind();\n      var targetTagName = _this.props.targetTagName;\n      if (fill) {\n        targetTagName = \"div\";\n      }\n      var finalTargetProps = isHoverInteractionKind ? {\n        // HOVER handlers\n        onBlur: _this.handleTargetBlur,\n        onFocus: _this.handleTargetFocus,\n        onMouseEnter: _this.handleMouseEnter,\n        onMouseLeave: _this.handleMouseLeave\n      } : {\n        // CLICK needs only one handler\n        onClick: _this.handleTargetClick\n      };\n      finalTargetProps[\"aria-haspopup\"] = \"true\";\n      finalTargetProps.className = classNames(Classes.POPOVER_TARGET, (_a = {}, _a[Classes.POPOVER_OPEN] = isOpen, _a), targetProps.className, targetClassName);\n      finalTargetProps.ref = referenceProps.ref;\n      var rawTarget = Utils.ensureElement(_this.understandChildren().target);\n      if (rawTarget === undefined) {\n        return null;\n      }\n      var rawTabIndex = rawTarget.props.tabIndex;\n      // ensure target is focusable if relevant prop enabled\n      var tabIndex = rawTabIndex == null && openOnTargetFocus && isHoverInteractionKind ? 0 : rawTabIndex;\n      var clonedTarget = React.cloneElement(rawTarget, {\n        className: classNames(rawTarget.props.className, (_b = {},\n        // this class is mainly useful for button targets; we should only apply it for uncontrolled popovers\n        // when they are opened by a user interaction\n        _b[Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind, _b)),\n        // force disable single Tooltip child when popover is open (BLUEPRINT-552)\n        /* eslint-disable-next-line deprecation/deprecation */\n        disabled: isOpen && Utils.isElementOfType(rawTarget, Tooltip) ? true : rawTarget.props.disabled,\n        tabIndex: tabIndex\n      });\n      var target = React.createElement(targetTagName, __assign(__assign({}, targetProps), finalTargetProps), clonedTarget);\n      return React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, target);\n    };\n    _this.isControlled = function () {\n      return _this.props.isOpen !== undefined;\n    };\n    _this.handleTargetFocus = function (e) {\n      var _a, _b;\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n          // ignore this focus event -- the target was already focused but the page itself\n          // lost focus (e.g. due to switching tabs).\n          return;\n        }\n        _this.handleMouseEnter(e);\n      }\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    _this.handleTargetBlur = function (e) {\n      var _a, _b;\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        // if the next element to receive focus is within the popover, we'll want to leave the\n        // popover open. e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n        // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n        // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n        // close the popover if necessary.\n        if (e.relatedTarget != null && !_this.isElementInPopover(e.relatedTarget)) {\n          _this.handleMouseLeave(e);\n        }\n      }\n      _this.lostFocusOnSamePage = e.relatedTarget != null;\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    _this.handleMouseEnter = function (e) {\n      var _a, _b;\n      _this.isMouseInTargetOrPopover = true;\n      // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n      // trigger the mouse leave event, as hovering over the popover shouldn't count.\n      if (!_this.props.usePortal && _this.isElementInPopover(e.target) && _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY && !_this.props.openOnTargetFocus) {\n        _this.handleMouseLeave(e);\n      } else if (!_this.props.disabled) {\n        // only begin opening popover when it is enabled\n        _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n      }\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseEnter) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    _this.handleMouseLeave = function (e) {\n      var _a, _b;\n      _this.isMouseInTargetOrPopover = false;\n      // wait until the event queue is flushed, because we want to leave the\n      // popover open if the mouse entered the popover immediately after\n      // leaving the target (or vice versa).\n      _this.setTimeout(function () {\n        if (_this.isMouseInTargetOrPopover) {\n          return;\n        }\n        // user-configurable closing delay is helpful when moving mouse from target to popover\n        _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n      });\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    _this.handlePopoverClick = function (e) {\n      var eventTarget = e.target;\n      var eventPopover = eventTarget.closest(\".\".concat(Classes.POPOVER));\n      var isEventFromSelf = eventPopover === _this.popoverRef.current;\n      var isEventPopoverCapturing = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER_CAPTURING_DISMISS);\n      // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n      var dismissElement = eventTarget.closest(\".\".concat(Classes.POPOVER_DISMISS, \", .\").concat(Classes.POPOVER_DISMISS_OVERRIDE));\n      var shouldDismiss = dismissElement != null && dismissElement.classList.contains(Classes.POPOVER_DISMISS);\n      var isDisabled = eventTarget.closest(\":disabled, .\".concat(Classes.DISABLED)) != null;\n      if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n        _this.setOpenState(false, e);\n      }\n    };\n    _this.handleOverlayClose = function (e) {\n      if (_this.targetElement === null || e === undefined) {\n        return;\n      }\n      var eventTarget = e.target;\n      // if click was in target, target event listener will handle things, so don't close\n      if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n        _this.setOpenState(false, e);\n      }\n    };\n    _this.handleTargetClick = function (e) {\n      var _a, _b;\n      // ensure click did not originate from within inline popover before closing\n      if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n        if (_this.props.isOpen == null) {\n          _this.setState(function (prevState) {\n            return {\n              isOpen: !prevState.isOpen\n            };\n          });\n        } else {\n          _this.setOpenState(!_this.props.isOpen, e);\n        }\n      }\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    /** Popper modifier that updates React state (for style properties) based on latest data. */\n    _this.updatePopoverState = function (data) {\n      // always set string; let shouldComponentUpdate determine if update is necessary\n      _this.setState({\n        transformOrigin: getTransformOrigin(data)\n      });\n      return data;\n    };\n    return _this;\n  }\n  Popover.prototype.render = function () {\n    var _a;\n    var _b;\n    // rename wrapper tag to begin with uppercase letter so it's recognized\n    // as JSX component instead of intrinsic element. but because of its\n    // type, tsc actually recognizes that it is _any_ intrinsic element, so\n    // it can typecheck the HTML props!!\n    var _c = this.props,\n      className = _c.className,\n      disabled = _c.disabled,\n      fill = _c.fill,\n      placement = _c.placement,\n      _d = _c.position,\n      position = _d === void 0 ? \"auto\" : _d,\n      shouldReturnFocusOnClose = _c.shouldReturnFocusOnClose;\n    var isOpen = this.state.isOpen;\n    var wrapperTagName = this.props.wrapperTagName;\n    if (fill) {\n      wrapperTagName = \"div\";\n    }\n    var isContentEmpty = Utils.ensureElement(this.understandChildren().content) == null;\n    // need to do this check in render(), because `isOpen` is derived from\n    // state, and state can't necessarily be accessed in validateProps.\n    if (isContentEmpty && !disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n      console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n    }\n    var wrapperClasses = classNames(Classes.POPOVER_WRAPPER, className, (_a = {}, _a[Classes.FILL] = fill, _a));\n    var defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;\n    var wrapper = React.createElement(wrapperTagName, {\n      className: wrapperClasses\n    }, React.createElement(Reference, {\n      innerRef: this.handleTargetRef\n    }, this.renderTarget), React.createElement(Overlay, {\n      autoFocus: (_b = this.props.autoFocus) !== null && _b !== void 0 ? _b : defaultAutoFocus,\n      backdropClassName: Classes.POPOVER_BACKDROP,\n      backdropProps: this.props.backdropProps,\n      canEscapeKeyClose: this.props.canEscapeKeyClose,\n      canOutsideClickClose: this.props.interactionKind === PopoverInteractionKind.CLICK,\n      className: this.props.portalClassName,\n      enforceFocus: this.props.enforceFocus,\n      hasBackdrop: this.props.hasBackdrop,\n      isOpen: isOpen && !isContentEmpty,\n      onClose: this.handleOverlayClose,\n      onClosed: this.props.onClosed,\n      onClosing: this.props.onClosing,\n      onOpened: this.props.onOpened,\n      onOpening: this.props.onOpening,\n      transitionDuration: this.props.transitionDuration,\n      transitionName: Classes.POPOVER,\n      usePortal: this.props.usePortal,\n      portalContainer: this.props.portalContainer,\n      // if hover interaciton, it doesn't make sense to take over focus control\n      shouldReturnFocusOnClose: this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose\n    }, React.createElement(Popper, {\n      innerRef: this.handlePopoverRef,\n      placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(position),\n      modifiers: this.getPopperModifiers()\n    }, this.renderPopover)));\n    return React.createElement(Manager, null, wrapper);\n  };\n  Popover.prototype.componentDidMount = function () {\n    this.updateDarkParent();\n  };\n  // eslint-disable-next-line deprecation/deprecation\n  Popover.prototype.componentDidUpdate = function (prevProps, prevState) {\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n    if (prevProps.popoverRef !== this.props.popoverRef) {\n      setRef(prevProps.popoverRef, null);\n      this.handlePopoverRef = refHandler(this, \"popoverElement\", this.props.popoverRef);\n      setRef(this.props.popoverRef, this.popoverElement);\n    }\n    this.updateDarkParent();\n    var nextIsOpen = this.getIsOpen(this.props);\n    if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n      this.setOpenState(nextIsOpen);\n      // tricky: setOpenState calls setState only if this.props.isOpen is\n      // not controlled, so we need to invoke setState manually here.\n      this.setState({\n        isOpen: nextIsOpen\n      });\n    } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n      // special case: close an uncontrolled popover when disabled is set to true\n      this.setOpenState(false);\n    }\n  };\n  // eslint-disable-next-line deprecation/deprecation\n  Popover.prototype.validateProps = function (props) {\n    if (props.isOpen == null && props.onInteraction != null) {\n      console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n    }\n    if (props.hasBackdrop && !props.usePortal) {\n      console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n    }\n    if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n      console.error(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n    }\n    if (props.placement !== undefined && props.position !== undefined) {\n      console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n    }\n    var childrenCount = React.Children.count(props.children);\n    var hasContentProp = props.content !== undefined;\n    var hasTargetProp = props.target !== undefined;\n    if (childrenCount === 0 && !hasTargetProp) {\n      console.error(Errors.POPOVER_REQUIRES_TARGET);\n    }\n    if (childrenCount > 2) {\n      console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n    }\n    if (childrenCount > 0 && hasTargetProp) {\n      console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n    }\n    if (childrenCount === 2 && hasContentProp) {\n      console.warn(Errors.POPOVER_WARN_DOUBLE_CONTENT);\n    }\n  };\n  Popover.prototype.updateDarkParent = function () {\n    if (this.props.usePortal && this.state.isOpen) {\n      var hasDarkParent = this.targetElement != null && this.targetElement.closest(\".\".concat(Classes.DARK)) != null;\n      this.setState({\n        hasDarkParent: hasDarkParent\n      });\n    }\n  };\n  // content and target can be specified as props or as children. this method\n  // normalizes the two approaches, preferring child over prop.\n  Popover.prototype.understandChildren = function () {\n    var _a = this.props,\n      children = _a.children,\n      contentProp = _a.content,\n      targetProp = _a.target;\n    // #validateProps asserts that 1 <= children.length <= 2 so content is optional\n    var _b = React.Children.toArray(children),\n      targetChild = _b[0],\n      contentChild = _b[1];\n    return {\n      content: contentChild == null ? contentProp : contentChild,\n      target: targetChild == null ? targetProp : targetChild\n    };\n  };\n  // eslint-disable-next-line deprecation/deprecation\n  Popover.prototype.getIsOpen = function (props) {\n    // disabled popovers should never be allowed to open.\n    if (props.disabled) {\n      return false;\n    } else if (props.isOpen != null) {\n      return props.isOpen;\n    } else {\n      return props.defaultIsOpen;\n    }\n  };\n  Popover.prototype.getPopperModifiers = function () {\n    var _a = this.props,\n      boundary = _a.boundary,\n      modifiers = _a.modifiers;\n    var _b = modifiers,\n      _c = _b.flip,\n      flip = _c === void 0 ? {} : _c,\n      _d = _b.preventOverflow,\n      preventOverflow = _d === void 0 ? {} : _d;\n    return __assign(__assign({}, modifiers), {\n      arrowOffset: {\n        enabled: this.isArrowEnabled(),\n        fn: arrowOffsetModifier,\n        order: 510\n      },\n      flip: __assign({\n        boundariesElement: boundary\n      }, flip),\n      preventOverflow: __assign({\n        boundariesElement: boundary\n      }, preventOverflow),\n      updatePopoverState: {\n        enabled: true,\n        fn: this.updatePopoverState,\n        order: 900\n      }\n    });\n  };\n  // a wrapper around setState({isOpen}) that will call props.onInteraction instead when in controlled mode.\n  // starts a timeout to delay changing the state if a non-zero duration is provided.\n  Popover.prototype.setOpenState = function (isOpen, e, timeout) {\n    var _this = this;\n    var _a, _b, _c, _d, _e;\n    // cancel any existing timeout because we have new state\n    (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n    if (timeout !== undefined && timeout > 0) {\n      this.cancelOpenTimeout = this.setTimeout(function () {\n        return _this.setOpenState(isOpen, e);\n      }, timeout);\n    } else {\n      if (this.props.isOpen == null) {\n        this.setState({\n          isOpen: isOpen\n        });\n      } else {\n        (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n      }\n      if (!isOpen) {\n        // non-null assertion because the only time `e` is undefined is when in controlled mode\n        // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n        (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n      }\n    }\n  };\n  Popover.prototype.isArrowEnabled = function () {\n    var _a = this.props,\n      minimal = _a.minimal,\n      modifiers = _a.modifiers;\n    // omitting `arrow` from `modifiers` uses Popper default, which does show an arrow.\n    return !minimal && ((modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow) == null || modifiers.arrow.enabled);\n  };\n  Popover.prototype.isElementInPopover = function (element) {\n    var _a;\n    return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.contains(element);\n  };\n  Popover.prototype.isHoverInteractionKind = function () {\n    return this.props.interactionKind === PopoverInteractionKind.HOVER || this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY;\n  };\n  Popover.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Popover\");\n  // eslint-disable-next-line deprecation/deprecation\n  Popover.defaultProps = {\n    boundary: \"scrollParent\",\n    captureDismiss: false,\n    defaultIsOpen: false,\n    disabled: false,\n    fill: false,\n    hasBackdrop: false,\n    hoverCloseDelay: 300,\n    hoverOpenDelay: 150,\n    inheritDarkTheme: true,\n    interactionKind: PopoverInteractionKind.CLICK,\n    minimal: false,\n    modifiers: {},\n    openOnTargetFocus: true,\n    shouldReturnFocusOnClose: false,\n    // N.B. we don't set a default for `placement` or `position` here because that would trigger\n    // a warning in validateProps if the other prop is specified by a user of this component\n    targetTagName: \"span\",\n    transitionDuration: 300,\n    usePortal: true,\n    wrapperTagName: \"span\"\n  };\n  return Popover;\n}(AbstractPureComponent2);\nexport { Popover };","map":{"version":3,"mappings":"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","names":["classNames","React","Manager","Popper","Reference","AbstractPureComponent2","Classes","refHandler","setRef","Errors","DISPLAYNAME_PREFIX","Utils","Overlay","ResizeSensor","Tooltip","PopoverArrow","positionToPlacement","arrowOffsetModifier","getTransformOrigin","PopoverInteractionKind","CLICK","CLICK_TARGET_ONLY","HOVER","HOVER_TARGET_ONLY","__extends","_this","createRef","hasDarkParent","isOpen","getIsOpen","props","transformOrigin","popoverRef","ref","targetElement","popperScheduleUpdate","popperProps","interactionKind","usePortal","state","scheduleUpdate","popoverHandlers","onClick","handlePopoverClick","onMouseEnter","handleMouseEnter","onMouseLeave","handleMouseLeave","popoverClasses","POPOVER","_a","DARK","inheritDarkTheme","MINIMAL","minimal","POPOVER_CAPTURING_DISMISS","captureDismiss","POPOVER_OUT_OF_BOUNDARIES","outOfBoundaries","popoverClassName","className","TRANSITION_CONTAINER","style","onResize","reposition","isArrowEnabled","arrowProps","placement","POPOVER_CONTENT","understandChildren","content","referenceProps","fill","openOnTargetFocus","targetClassName","_d","targetProps","isControlled","isHoverInteractionKind","targetTagName","finalTargetProps","onBlur","handleTargetBlur","onFocus","handleTargetFocus","handleTargetClick","POPOVER_TARGET","POPOVER_OPEN","rawTarget","ensureElement","target","undefined","rawTabIndex","tabIndex","clonedTarget","cloneElement","_b","ACTIVE","disabled","isElementOfType","createElement","e","relatedTarget","lostFocusOnSamePage","isElementInPopover","isMouseInTargetOrPopover","setOpenState","hoverOpenDelay","setTimeout","hoverCloseDelay","eventTarget","eventPopover","closest","isEventFromSelf","current","isEventPopoverCapturing","classList","contains","dismissElement","POPOVER_DISMISS","POPOVER_DISMISS_OVERRIDE","shouldDismiss","isDisabled","DISABLED","elementIsOrContains","nativeEvent","KeyboardEvent","setState","prevState","data","Popover","position","shouldReturnFocusOnClose","wrapperTagName","isContentEmpty","isNodeEnv","console","warn","POPOVER_WARN_EMPTY_CONTENT","wrapperClasses","POPOVER_WRAPPER","FILL","defaultAutoFocus","wrapper","innerRef","handleTargetRef","renderTarget","autoFocus","backdropClassName","POPOVER_BACKDROP","backdropProps","canEscapeKeyClose","canOutsideClickClose","portalClassName","enforceFocus","hasBackdrop","onClose","handleOverlayClose","onClosed","onClosing","onOpened","onOpening","transitionDuration","transitionName","portalContainer","handlePopoverRef","modifiers","getPopperModifiers","renderPopover","updateDarkParent","prevProps","_super","componentDidUpdate","popoverElement","nextIsOpen","onInteraction","POPOVER_WARN_UNCONTROLLED_ONINTERACTION","POPOVER_WARN_HAS_BACKDROP_INLINE","error","POPOVER_HAS_BACKDROP_INTERACTION","POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX","childrenCount","Children","count","children","hasContentProp","hasTargetProp","POPOVER_REQUIRES_TARGET","POPOVER_WARN_TOO_MANY_CHILDREN","POPOVER_WARN_DOUBLE_TARGET","POPOVER_WARN_DOUBLE_CONTENT","contentProp","targetProp","toArray","targetChild","contentChild","defaultIsOpen","boundary","_c","flip","preventOverflow","arrowOffset","enabled","fn","order","boundariesElement","updatePopoverState","timeout","cancelOpenTimeout","arrow","element"],"sources":["/Users/mansidabriwal/Documents/Web design class/React-Assignment/react-app/node_modules/@blueprintjs/core/src/components/popover/popover.tsx"],"sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport { ModifierFn } from \"popper.js\";\nimport * as React from \"react\";\nimport { Manager, Popper, PopperChildrenProps, Reference, ReferenceChildrenProps } from \"react-popper\";\n\nimport { AbstractPureComponent2, Classes, refHandler, setRef } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, HTMLDivProps } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Overlay } from \"../overlay/overlay\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverMigrationUtils\";\nimport { IPopoverSharedProps, PopperModifiers } from \"./popoverSharedProps\";\nimport { arrowOffsetModifier, getTransformOrigin } from \"./popperUtils\";\n\nexport const PopoverInteractionKind = {\n    CLICK: \"click\" as \"click\",\n    CLICK_TARGET_ONLY: \"click-target\" as \"click-target\",\n    HOVER: \"hover\" as \"hover\",\n    HOVER_TARGET_ONLY: \"hover-target\" as \"hover-target\",\n};\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type PopoverInteractionKind = typeof PopoverInteractionKind[keyof typeof PopoverInteractionKind];\n\n/** @deprecated migrate to Popover2, use Popover2Props */\nexport interface IPopoverProps extends IPopoverSharedProps {\n    /** HTML props for the backdrop element. Can be combined with `backdropClassName`. */\n    backdropProps?: React.HTMLProps<HTMLDivElement>;\n\n    /**\n     * The content displayed inside the popover. This can instead be provided as\n     * the _second_ element in `children` (first is `target`).\n     */\n    content?: string | JSX.Element;\n\n    /**\n     * Whether the wrapper and target should take up the full width of their container.\n     * Note that supplying `true` for this prop will force  `targetTagName=\"div\"` and\n     * `wrapperTagName=\"div\"`.\n     */\n    fill?: boolean;\n\n    /**\n     * The kind of interaction that triggers the display of the popover.\n     *\n     * @default PopoverInteractionKind.CLICK\n     */\n    interactionKind?: PopoverInteractionKind;\n\n    /**\n     * Enables an invisible overlay beneath the popover that captures clicks and\n     * prevents interaction with the rest of the document until the popover is\n     * closed. This prop is only available when `interactionKind` is\n     * `PopoverInteractionKind.CLICK`. When popovers with backdrop are opened,\n     * they become focused.\n     *\n     * @default false\n     */\n    hasBackdrop?: boolean;\n\n    /**\n     * Whether the application should return focus to the last active element in the\n     * document after this popover closes.\n     *\n     * This is automatically set to `false` if this is a hover interaction popover.\n     *\n     * If you are attaching a popover _and_ a tooltip to the same target, you must take\n     * care to either disable this prop for the popover _or_ disable the tooltip's\n     * `openOnTargetFocus` prop.\n     *\n     * @default false\n     */\n    shouldReturnFocusOnClose?: boolean;\n\n    /**\n     * Ref supplied to the `Classes.POPOVER` element.\n     */\n    popoverRef?: React.Ref<HTMLElement>;\n\n    /**\n     * The target to which the popover content is attached. This can instead be\n     * provided as the _first_ element in `children`.\n     */\n    target?: string | JSX.Element;\n}\n\nexport interface IPopoverState {\n    transformOrigin: string;\n    isOpen: boolean;\n    hasDarkParent: boolean;\n}\n\n/** @deprecated use { Popover2 } from \"@blueprintjs/popover2\" */\n// eslint-disable-next-line deprecation/deprecation\nexport class Popover extends AbstractPureComponent2<IPopoverProps, IPopoverState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Popover`;\n\n    private popoverRef = React.createRef<HTMLDivElement>();\n\n    // eslint-disable-next-line deprecation/deprecation\n    public static defaultProps: IPopoverProps = {\n        boundary: \"scrollParent\",\n        captureDismiss: false,\n        defaultIsOpen: false,\n        disabled: false,\n        fill: false,\n        hasBackdrop: false,\n        hoverCloseDelay: 300,\n        hoverOpenDelay: 150,\n        inheritDarkTheme: true,\n        interactionKind: PopoverInteractionKind.CLICK,\n        minimal: false,\n        modifiers: {},\n        openOnTargetFocus: true,\n        shouldReturnFocusOnClose: false,\n        // N.B. we don't set a default for `placement` or `position` here because that would trigger\n        // a warning in validateProps if the other prop is specified by a user of this component\n        targetTagName: \"span\",\n        transitionDuration: 300,\n        usePortal: true,\n        wrapperTagName: \"span\",\n    };\n\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     */\n    public popoverElement: HTMLElement | null = null;\n\n    /** DOM element that contains the target. */\n    public targetElement: HTMLElement | null = null;\n\n    public state: IPopoverState = {\n        hasDarkParent: false,\n        isOpen: this.getIsOpen(this.props),\n        transformOrigin: \"\",\n    };\n\n    private cancelOpenTimeout?: () => void;\n\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    private isMouseInTargetOrPopover = false;\n\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    private lostFocusOnSamePage = true;\n\n    // Reference to the Poppper.scheduleUpdate() function, this changes every time the popper is mounted\n    private popperScheduleUpdate?: () => void;\n\n    private handlePopoverRef: React.Ref<HTMLElement> = refHandler(this, \"popoverElement\", this.props.popoverRef);\n\n    private handleTargetRef = (ref: HTMLElement | null) => (this.targetElement = ref);\n\n    public render() {\n        // rename wrapper tag to begin with uppercase letter so it's recognized\n        // as JSX component instead of intrinsic element. but because of its\n        // type, tsc actually recognizes that it is _any_ intrinsic element, so\n        // it can typecheck the HTML props!!\n        const { className, disabled, fill, placement, position = \"auto\", shouldReturnFocusOnClose } = this.props;\n        const { isOpen } = this.state;\n        let { wrapperTagName } = this.props;\n        if (fill) {\n            wrapperTagName = \"div\";\n        }\n\n        const isContentEmpty = Utils.ensureElement(this.understandChildren().content) == null;\n        // need to do this check in render(), because `isOpen` is derived from\n        // state, and state can't necessarily be accessed in validateProps.\n        if (isContentEmpty && !disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n            console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n        }\n\n        const wrapperClasses = classNames(Classes.POPOVER_WRAPPER, className, {\n            [Classes.FILL]: fill,\n        });\n\n        const defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;\n\n        const wrapper = React.createElement(\n            wrapperTagName!,\n            { className: wrapperClasses },\n            <Reference innerRef={this.handleTargetRef}>{this.renderTarget}</Reference>,\n            <Overlay\n                autoFocus={this.props.autoFocus ?? defaultAutoFocus}\n                backdropClassName={Classes.POPOVER_BACKDROP}\n                backdropProps={this.props.backdropProps}\n                canEscapeKeyClose={this.props.canEscapeKeyClose}\n                canOutsideClickClose={this.props.interactionKind === PopoverInteractionKind.CLICK}\n                className={this.props.portalClassName}\n                enforceFocus={this.props.enforceFocus}\n                hasBackdrop={this.props.hasBackdrop}\n                isOpen={isOpen && !isContentEmpty}\n                onClose={this.handleOverlayClose}\n                onClosed={this.props.onClosed}\n                onClosing={this.props.onClosing}\n                onOpened={this.props.onOpened}\n                onOpening={this.props.onOpening}\n                transitionDuration={this.props.transitionDuration}\n                transitionName={Classes.POPOVER}\n                usePortal={this.props.usePortal}\n                portalContainer={this.props.portalContainer}\n                // if hover interaciton, it doesn't make sense to take over focus control\n                shouldReturnFocusOnClose={this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose}\n            >\n                <Popper\n                    innerRef={this.handlePopoverRef}\n                    placement={placement ?? positionToPlacement(position)}\n                    modifiers={this.getPopperModifiers()}\n                >\n                    {this.renderPopover}\n                </Popper>\n            </Overlay>,\n        );\n\n        return <Manager>{wrapper}</Manager>;\n    }\n\n    public componentDidMount() {\n        this.updateDarkParent();\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    public componentDidUpdate(prevProps: IPopoverProps, prevState: IPopoverState) {\n        super.componentDidUpdate(prevProps, prevState);\n\n        if (prevProps.popoverRef !== this.props.popoverRef) {\n            setRef(prevProps.popoverRef, null);\n            this.handlePopoverRef = refHandler(this, \"popoverElement\", this.props.popoverRef);\n            setRef(this.props.popoverRef, this.popoverElement);\n        }\n\n        this.updateDarkParent();\n\n        const nextIsOpen = this.getIsOpen(this.props);\n\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n            this.setOpenState(nextIsOpen);\n            // tricky: setOpenState calls setState only if this.props.isOpen is\n            // not controlled, so we need to invoke setState manually here.\n            this.setState({ isOpen: nextIsOpen });\n        } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n            // special case: close an uncontrolled popover when disabled is set to true\n            this.setOpenState(false);\n        }\n    }\n\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    public reposition = () => this.popperScheduleUpdate?.();\n\n    // eslint-disable-next-line deprecation/deprecation\n    protected validateProps(props: IPopoverProps & { children?: React.ReactNode }) {\n        if (props.isOpen == null && props.onInteraction != null) {\n            console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n        }\n        if (props.hasBackdrop && !props.usePortal) {\n            console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n        }\n        if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n            console.error(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n        }\n        if (props.placement !== undefined && props.position !== undefined) {\n            console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n        }\n\n        const childrenCount = React.Children.count(props.children);\n        const hasContentProp = props.content !== undefined;\n        const hasTargetProp = props.target !== undefined;\n\n        if (childrenCount === 0 && !hasTargetProp) {\n            console.error(Errors.POPOVER_REQUIRES_TARGET);\n        }\n        if (childrenCount > 2) {\n            console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n        }\n        if (childrenCount > 0 && hasTargetProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n        }\n        if (childrenCount === 2 && hasContentProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_CONTENT);\n        }\n    }\n\n    private updateDarkParent() {\n        if (this.props.usePortal && this.state.isOpen) {\n            const hasDarkParent = this.targetElement != null && this.targetElement.closest(`.${Classes.DARK}`) != null;\n            this.setState({ hasDarkParent });\n        }\n    }\n\n    private renderPopover = (popperProps: PopperChildrenProps) => {\n        const { interactionKind, usePortal } = this.props;\n        const { transformOrigin } = this.state;\n\n        // Need to update our reference to this on every render as it will change.\n        this.popperScheduleUpdate = popperProps.scheduleUpdate;\n\n        const popoverHandlers: HTMLDivProps = {\n            // always check popover clicks for dismiss class\n            onClick: this.handlePopoverClick,\n        };\n        if (\n            interactionKind === PopoverInteractionKind.HOVER ||\n            (!usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY)\n        ) {\n            popoverHandlers.onMouseEnter = this.handleMouseEnter;\n            popoverHandlers.onMouseLeave = this.handleMouseLeave;\n        }\n\n        const popoverClasses = classNames(\n            Classes.POPOVER,\n            {\n                [Classes.DARK]: this.props.inheritDarkTheme && this.state.hasDarkParent,\n                [Classes.MINIMAL]: this.props.minimal,\n                [Classes.POPOVER_CAPTURING_DISMISS]: this.props.captureDismiss,\n                [Classes.POPOVER_OUT_OF_BOUNDARIES]: popperProps.outOfBoundaries === true,\n            },\n            this.props.popoverClassName,\n        );\n\n        return (\n            <div className={Classes.TRANSITION_CONTAINER} ref={popperProps.ref} style={popperProps.style}>\n                <ResizeSensor onResize={this.reposition}>\n                    <div\n                        className={popoverClasses}\n                        style={{ transformOrigin }}\n                        ref={this.popoverRef}\n                        {...popoverHandlers}\n                    >\n                        {this.isArrowEnabled() && (\n                            <PopoverArrow arrowProps={popperProps.arrowProps} placement={popperProps.placement} />\n                        )}\n                        <div className={Classes.POPOVER_CONTENT}>{this.understandChildren().content}</div>\n                    </div>\n                </ResizeSensor>\n            </div>\n        );\n    };\n\n    private renderTarget = (referenceProps: ReferenceChildrenProps) => {\n        const { fill, openOnTargetFocus, targetClassName, targetProps = {} } = this.props;\n        const { isOpen } = this.state;\n        const isControlled = this.isControlled();\n        const isHoverInteractionKind = this.isHoverInteractionKind();\n        let { targetTagName } = this.props;\n        if (fill) {\n            targetTagName = \"div\";\n        }\n\n        const finalTargetProps: React.HTMLProps<HTMLElement> = isHoverInteractionKind\n            ? {\n                  // HOVER handlers\n                  onBlur: this.handleTargetBlur,\n                  onFocus: this.handleTargetFocus,\n                  onMouseEnter: this.handleMouseEnter,\n                  onMouseLeave: this.handleMouseLeave,\n              }\n            : {\n                  // CLICK needs only one handler\n                  onClick: this.handleTargetClick,\n              };\n        finalTargetProps[\"aria-haspopup\"] = \"true\";\n        finalTargetProps.className = classNames(\n            Classes.POPOVER_TARGET,\n            { [Classes.POPOVER_OPEN]: isOpen },\n            targetProps.className,\n            targetClassName,\n        );\n        finalTargetProps.ref = referenceProps.ref;\n\n        const rawTarget = Utils.ensureElement(this.understandChildren().target);\n\n        if (rawTarget === undefined) {\n            return null;\n        }\n\n        const rawTabIndex = rawTarget.props.tabIndex;\n        // ensure target is focusable if relevant prop enabled\n        const tabIndex = rawTabIndex == null && openOnTargetFocus && isHoverInteractionKind ? 0 : rawTabIndex;\n        const clonedTarget: JSX.Element = React.cloneElement(rawTarget, {\n            className: classNames(rawTarget.props.className, {\n                // this class is mainly useful for button targets; we should only apply it for uncontrolled popovers\n                // when they are opened by a user interaction\n                [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n            }),\n            // force disable single Tooltip child when popover is open (BLUEPRINT-552)\n            /* eslint-disable-next-line deprecation/deprecation */\n            disabled: isOpen && Utils.isElementOfType(rawTarget, Tooltip) ? true : rawTarget.props.disabled,\n            tabIndex,\n        });\n        const target = React.createElement(\n            targetTagName!,\n            {\n                ...targetProps,\n                ...finalTargetProps,\n            },\n            clonedTarget,\n        );\n\n        return <ResizeSensor onResize={this.reposition}>{target}</ResizeSensor>;\n    };\n\n    // content and target can be specified as props or as children. this method\n    // normalizes the two approaches, preferring child over prop.\n    private understandChildren() {\n        const { children, content: contentProp, target: targetProp } = this.props;\n        // #validateProps asserts that 1 <= children.length <= 2 so content is optional\n        const [targetChild, contentChild] = React.Children.toArray(children);\n        return {\n            content: contentChild == null ? contentProp : contentChild,\n            target: targetChild == null ? targetProp : targetChild,\n        };\n    }\n\n    private isControlled = () => this.props.isOpen !== undefined;\n\n    // eslint-disable-next-line deprecation/deprecation\n    private getIsOpen(props: IPopoverProps) {\n        // disabled popovers should never be allowed to open.\n        if (props.disabled) {\n            return false;\n        } else if (props.isOpen != null) {\n            return props.isOpen;\n        } else {\n            return props.defaultIsOpen!;\n        }\n    }\n\n    private getPopperModifiers(): PopperModifiers {\n        const { boundary, modifiers } = this.props;\n        const { flip = {}, preventOverflow = {} } = modifiers!;\n        return {\n            ...modifiers,\n            arrowOffset: {\n                enabled: this.isArrowEnabled(),\n                fn: arrowOffsetModifier,\n                order: 510,\n            },\n            flip: { boundariesElement: boundary, ...flip },\n            preventOverflow: { boundariesElement: boundary, ...preventOverflow },\n            updatePopoverState: {\n                enabled: true,\n                fn: this.updatePopoverState,\n                order: 900,\n            },\n        };\n    }\n\n    private handleTargetFocus = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget == null && !this.lostFocusOnSamePage) {\n                // ignore this focus event -- the target was already focused but the page itself\n                // lost focus (e.g. due to switching tabs).\n                return;\n            }\n            this.handleMouseEnter(e as unknown as React.MouseEvent<HTMLElement>);\n        }\n        this.props.targetProps?.onFocus?.(e);\n    };\n\n    private handleTargetBlur = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            // if the next element to receive focus is within the popover, we'll want to leave the\n            // popover open. e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n            // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n            // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n            // close the popover if necessary.\n            if (e.relatedTarget != null && !this.isElementInPopover(e.relatedTarget as HTMLElement)) {\n                this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);\n            }\n        }\n        this.lostFocusOnSamePage = e.relatedTarget != null;\n        this.props.targetProps?.onBlur?.(e);\n    };\n\n    private handleMouseEnter = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = true;\n\n        // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n        // trigger the mouse leave event, as hovering over the popover shouldn't count.\n        if (\n            !this.props.usePortal &&\n            this.isElementInPopover(e.target as Element) &&\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY &&\n            !this.props.openOnTargetFocus\n        ) {\n            this.handleMouseLeave(e);\n        } else if (!this.props.disabled) {\n            // only begin opening popover when it is enabled\n            this.setOpenState(true, e, this.props.hoverOpenDelay);\n        }\n        this.props.targetProps?.onMouseEnter?.(e);\n    };\n\n    private handleMouseLeave = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = false;\n\n        // wait until the event queue is flushed, because we want to leave the\n        // popover open if the mouse entered the popover immediately after\n        // leaving the target (or vice versa).\n        this.setTimeout(() => {\n            if (this.isMouseInTargetOrPopover) {\n                return;\n            }\n            // user-configurable closing delay is helpful when moving mouse from target to popover\n            this.setOpenState(false, e, this.props.hoverCloseDelay);\n        });\n        this.props.targetProps?.onMouseLeave?.(e);\n    };\n\n    private handlePopoverClick = (e: React.MouseEvent<HTMLElement>) => {\n        const eventTarget = e.target as HTMLElement;\n        const eventPopover = eventTarget.closest(`.${Classes.POPOVER}`);\n        const isEventFromSelf = eventPopover === this.popoverRef.current;\n        const isEventPopoverCapturing = eventPopover?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS);\n        // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n        const dismissElement = eventTarget.closest(`.${Classes.POPOVER_DISMISS}, .${Classes.POPOVER_DISMISS_OVERRIDE}`);\n        const shouldDismiss = dismissElement != null && dismissElement.classList.contains(Classes.POPOVER_DISMISS);\n        const isDisabled = eventTarget.closest(`:disabled, .${Classes.DISABLED}`) != null;\n        if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleOverlayClose = (e?: React.SyntheticEvent<HTMLElement>) => {\n        if (this.targetElement === null || e === undefined) {\n            return;\n        }\n\n        const eventTarget = e.target as HTMLElement;\n        // if click was in target, target event listener will handle things, so don't close\n        if (!Utils.elementIsOrContains(this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleTargetClick = (e: React.MouseEvent<HTMLElement>) => {\n        // ensure click did not originate from within inline popover before closing\n        if (!this.props.disabled && !this.isElementInPopover(e.target as HTMLElement)) {\n            if (this.props.isOpen == null) {\n                this.setState(prevState => ({ isOpen: !prevState.isOpen }));\n            } else {\n                this.setOpenState(!this.props.isOpen, e);\n            }\n        }\n        this.props.targetProps?.onClick?.(e);\n    };\n\n    // a wrapper around setState({isOpen}) that will call props.onInteraction instead when in controlled mode.\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\n    private setOpenState(isOpen: boolean, e?: React.SyntheticEvent<HTMLElement>, timeout?: number) {\n        // cancel any existing timeout because we have new state\n        this.cancelOpenTimeout?.();\n        if (timeout !== undefined && timeout > 0) {\n            this.cancelOpenTimeout = this.setTimeout(() => this.setOpenState(isOpen, e), timeout);\n        } else {\n            if (this.props.isOpen == null) {\n                this.setState({ isOpen });\n            } else {\n                this.props.onInteraction?.(isOpen, e);\n            }\n            if (!isOpen) {\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n                this.props.onClose?.(e!);\n            }\n        }\n    }\n\n    private isArrowEnabled() {\n        const { minimal, modifiers } = this.props;\n        // omitting `arrow` from `modifiers` uses Popper default, which does show an arrow.\n        return !minimal && (modifiers?.arrow == null || modifiers.arrow.enabled);\n    }\n\n    private isElementInPopover(element: Element) {\n        return this.popoverElement?.contains(element);\n    }\n\n    private isHoverInteractionKind() {\n        return (\n            this.props.interactionKind === PopoverInteractionKind.HOVER ||\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY\n        );\n    }\n\n    /** Popper modifier that updates React state (for style properties) based on latest data. */\n    private updatePopoverState: ModifierFn = data => {\n        // always set string; let shouldComponentUpdate determine if update is necessary\n        this.setState({ transformOrigin: getTransformOrigin(data) });\n        return data;\n    };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}