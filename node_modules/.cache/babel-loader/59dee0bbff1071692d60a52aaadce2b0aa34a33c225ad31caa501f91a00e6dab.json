{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __spreadArray } from \"tslib\";\nimport * as React from \"react\";\nimport { HOTKEYS_PROVIDER_NOT_FOUND } from \"../../common/errors\";\nimport { comboMatches, getKeyCombo, parseKeyCombo } from \"../../components/hotkeys/hotkeyParser\";\nimport { HotkeysContext } from \"../../context\";\n/**\n * React hook to register global and local hotkeys for a component.\n *\n * @param keys list of hotkeys to configure\n * @param options hook options\n */\nexport function useHotkeys(keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = options.document,\n    document = _a === void 0 ? getDefaultDocument() : _a,\n    _b = options.showDialogKeyCombo,\n    showDialogKeyCombo = _b === void 0 ? \"?\" : _b;\n  var localKeys = React.useMemo(function () {\n    return keys.filter(function (k) {\n      return !k.global;\n    }).map(function (k) {\n      return {\n        combo: parseKeyCombo(k.combo),\n        config: k\n      };\n    });\n  }, [keys]);\n  var globalKeys = React.useMemo(function () {\n    return keys.filter(function (k) {\n      return k.global;\n    }).map(function (k) {\n      return {\n        combo: parseKeyCombo(k.combo),\n        config: k\n      };\n    });\n  }, [keys]);\n  // register keys with global context\n  var _c = React.useContext(HotkeysContext),\n    state = _c[0],\n    dispatch = _c[1];\n  if (!state.hasProvider) {\n    React.useEffect(function () {\n      return console.warn(HOTKEYS_PROVIDER_NOT_FOUND);\n    }, []);\n  }\n  // we can still bind the hotkeys if there is no HotkeysProvider, they just won't show up in the dialog\n  React.useEffect(function () {\n    var payload = __spreadArray(__spreadArray([], globalKeys.map(function (k) {\n      return k.config;\n    }), true), localKeys.map(function (k) {\n      return k.config;\n    }), true);\n    dispatch({\n      type: \"ADD_HOTKEYS\",\n      payload: payload\n    });\n    return function () {\n      return dispatch({\n        type: \"REMOVE_HOTKEYS\",\n        payload: payload\n      });\n    };\n  }, [keys]);\n  var invokeNamedCallbackIfComboRecognized = function (global, combo, callbackName, e) {\n    var _a, _b;\n    var isTextInput = isTargetATextInput(e);\n    for (var _i = 0, _c = global ? globalKeys : localKeys; _i < _c.length; _i++) {\n      var key = _c[_i];\n      var _d = key.config,\n        _e = _d.allowInInput,\n        allowInInput = _e === void 0 ? false : _e,\n        _f = _d.disabled,\n        disabled = _f === void 0 ? false : _f,\n        _g = _d.preventDefault,\n        preventDefault = _g === void 0 ? false : _g,\n        _h = _d.stopPropagation,\n        stopPropagation = _h === void 0 ? false : _h;\n      var shouldIgnore = isTextInput && !allowInInput || disabled;\n      if (!shouldIgnore && comboMatches(key.combo, combo)) {\n        if (preventDefault) {\n          e.preventDefault();\n        }\n        if (stopPropagation) {\n          // set a flag just for unit testing. not meant to be referenced in feature work.\n          e.isPropagationStopped = true;\n          e.stopPropagation();\n        }\n        (_b = (_a = key.config)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n      }\n    }\n  };\n  var handleGlobalKeyDown = React.useCallback(function (e) {\n    // special case for global keydown: if '?' is pressed, open the hotkeys dialog\n    var combo = getKeyCombo(e);\n    var isTextInput = isTargetATextInput(e);\n    if (!isTextInput && comboMatches(parseKeyCombo(showDialogKeyCombo), combo)) {\n      dispatch({\n        type: \"OPEN_DIALOG\"\n      });\n    } else {\n      invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyDown\", e);\n    }\n  }, [globalKeys]);\n  var handleGlobalKeyUp = React.useCallback(function (e) {\n    return invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyUp\", e);\n  }, [globalKeys]);\n  var handleLocalKeyDown = React.useCallback(function (e) {\n    return invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyDown\", e.nativeEvent);\n  }, [localKeys]);\n  var handleLocalKeyUp = React.useCallback(function (e) {\n    return invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyUp\", e.nativeEvent);\n  }, [localKeys]);\n  React.useEffect(function () {\n    // document is guaranteed to be defined inside effects\n    document.addEventListener(\"keydown\", handleGlobalKeyDown);\n    document.addEventListener(\"keyup\", handleGlobalKeyUp);\n    return function () {\n      document.removeEventListener(\"keydown\", handleGlobalKeyDown);\n      document.removeEventListener(\"keyup\", handleGlobalKeyUp);\n    };\n  }, [handleGlobalKeyDown, handleGlobalKeyUp]);\n  return {\n    handleKeyDown: handleLocalKeyDown,\n    handleKeyUp: handleLocalKeyUp\n  };\n}\n/**\n * @returns true if the event target is a text input which should take priority over hotkey bindings\n */\nfunction isTargetATextInput(e) {\n  var elem = e.target;\n  // we check these cases for unit testing, but this should not happen\n  // during normal operation\n  if (elem == null || elem.closest == null) {\n    return false;\n  }\n  var editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n  if (editable == null) {\n    return false;\n  }\n  // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n  if (editable.tagName.toLowerCase() === \"input\") {\n    var inputType = editable.type;\n    if (inputType === \"checkbox\" || inputType === \"radio\") {\n      return false;\n    }\n  }\n  // don't let read-only fields prevent hotkey behavior\n  if (editable.readOnly) {\n    return false;\n  }\n  return true;\n}\nfunction getDefaultDocument() {\n  if (typeof window === \"undefined\") {\n    return undefined;\n  }\n  return window.document;\n}","map":{"version":3,"mappings":"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","names":["React","HOTKEYS_PROVIDER_NOT_FOUND","comboMatches","getKeyCombo","parseKeyCombo","HotkeysContext","useHotkeys","keys","options","document","getDefaultDocument","_b","showDialogKeyCombo","localKeys","useMemo","filter","k","global","map","combo","config","globalKeys","useContext","state","dispatch","hasProvider","useEffect","warn","payload","type","invokeNamedCallbackIfComboRecognized","callbackName","e","isTextInput","isTargetATextInput","_c","_i","key","_e","allowInInput","_f","disabled","_g","preventDefault","_h","stopPropagation","shouldIgnore","isPropagationStopped","handleGlobalKeyDown","useCallback","handleGlobalKeyUp","handleLocalKeyDown","nativeEvent","handleLocalKeyUp","addEventListener","removeEventListener","handleKeyDown","handleKeyUp","elem","target","closest","editable","tagName","toLowerCase","inputType","readOnly","window","undefined"],"sources":["/Users/mansidabriwal/Documents/Web design class/React-Assignment/react-app/node_modules/@blueprintjs/core/src/hooks/hotkeys/useHotkeys.ts"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as React from \"react\";\n\nimport { HOTKEYS_PROVIDER_NOT_FOUND } from \"../../common/errors\";\nimport { comboMatches, getKeyCombo, IKeyCombo, parseKeyCombo } from \"../../components/hotkeys/hotkeyParser\";\nimport { HotkeysContext } from \"../../context\";\nimport { HotkeyConfig } from \"./hotkeyConfig\";\n\nexport interface UseHotkeysOptions {\n    /**\n     * A custom document to reference when binding global event handlers.\n     * This can be useful when using iframes in an application.\n     *\n     * @default window.document\n     */\n    document?: Document;\n\n    /**\n     * The key combo which will trigger the hotkeys dialog to open.\n     *\n     * @default \"?\"\n     */\n    showDialogKeyCombo?: string;\n}\n\nexport interface UseHotkeysReturnValue {\n    handleKeyDown: React.KeyboardEventHandler<HTMLElement>;\n    handleKeyUp: React.KeyboardEventHandler<HTMLElement>;\n}\n\n/**\n * React hook to register global and local hotkeys for a component.\n *\n * @param keys list of hotkeys to configure\n * @param options hook options\n */\nexport function useHotkeys(keys: readonly HotkeyConfig[], options: UseHotkeysOptions = {}): UseHotkeysReturnValue {\n    const { document = getDefaultDocument(), showDialogKeyCombo = \"?\" } = options;\n    const localKeys = React.useMemo(\n        () =>\n            keys\n                .filter(k => !k.global)\n                .map(k => ({\n                    combo: parseKeyCombo(k.combo),\n                    config: k,\n                })),\n        [keys],\n    );\n    const globalKeys = React.useMemo(\n        () =>\n            keys\n                .filter(k => k.global)\n                .map(k => ({\n                    combo: parseKeyCombo(k.combo),\n                    config: k,\n                })),\n        [keys],\n    );\n\n    // register keys with global context\n    const [state, dispatch] = React.useContext(HotkeysContext);\n\n    if (!state.hasProvider) {\n        React.useEffect(() => console.warn(HOTKEYS_PROVIDER_NOT_FOUND), []);\n    }\n\n    // we can still bind the hotkeys if there is no HotkeysProvider, they just won't show up in the dialog\n    React.useEffect(() => {\n        const payload = [...globalKeys.map(k => k.config), ...localKeys.map(k => k.config)];\n        dispatch({ type: \"ADD_HOTKEYS\", payload });\n        return () => dispatch({ type: \"REMOVE_HOTKEYS\", payload });\n    }, [keys]);\n\n    const invokeNamedCallbackIfComboRecognized = (\n        global: boolean,\n        combo: IKeyCombo,\n        callbackName: \"onKeyDown\" | \"onKeyUp\",\n        e: KeyboardEvent,\n    ) => {\n        const isTextInput = isTargetATextInput(e);\n        for (const key of global ? globalKeys : localKeys) {\n            const {\n                allowInInput = false,\n                disabled = false,\n                preventDefault = false,\n                stopPropagation = false,\n            } = key.config;\n            const shouldIgnore = (isTextInput && !allowInInput) || disabled;\n            if (!shouldIgnore && comboMatches(key.combo, combo)) {\n                if (preventDefault) {\n                    e.preventDefault();\n                }\n                if (stopPropagation) {\n                    // set a flag just for unit testing. not meant to be referenced in feature work.\n                    (e as any).isPropagationStopped = true;\n                    e.stopPropagation();\n                }\n                key.config[callbackName]?.(e);\n            }\n        }\n    };\n\n    const handleGlobalKeyDown = React.useCallback(\n        (e: KeyboardEvent) => {\n            // special case for global keydown: if '?' is pressed, open the hotkeys dialog\n            const combo = getKeyCombo(e);\n            const isTextInput = isTargetATextInput(e);\n            if (!isTextInput && comboMatches(parseKeyCombo(showDialogKeyCombo), combo)) {\n                dispatch({ type: \"OPEN_DIALOG\" });\n            } else {\n                invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyDown\", e);\n            }\n        },\n        [globalKeys],\n    );\n    const handleGlobalKeyUp = React.useCallback(\n        (e: KeyboardEvent) => invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyUp\", e),\n        [globalKeys],\n    );\n\n    const handleLocalKeyDown = React.useCallback(\n        (e: React.KeyboardEvent<HTMLElement>) =>\n            invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyDown\", e.nativeEvent),\n        [localKeys],\n    );\n    const handleLocalKeyUp = React.useCallback(\n        (e: React.KeyboardEvent<HTMLElement>) =>\n            invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyUp\", e.nativeEvent),\n        [localKeys],\n    );\n\n    React.useEffect(() => {\n        // document is guaranteed to be defined inside effects\n        document!.addEventListener(\"keydown\", handleGlobalKeyDown);\n        document!.addEventListener(\"keyup\", handleGlobalKeyUp);\n        return () => {\n            document!.removeEventListener(\"keydown\", handleGlobalKeyDown);\n            document!.removeEventListener(\"keyup\", handleGlobalKeyUp);\n        };\n    }, [handleGlobalKeyDown, handleGlobalKeyUp]);\n\n    return { handleKeyDown: handleLocalKeyDown, handleKeyUp: handleLocalKeyUp };\n}\n\n/**\n * @returns true if the event target is a text input which should take priority over hotkey bindings\n */\nfunction isTargetATextInput(e: KeyboardEvent) {\n    const elem = e.target as HTMLElement;\n    // we check these cases for unit testing, but this should not happen\n    // during normal operation\n    if (elem == null || elem.closest == null) {\n        return false;\n    }\n\n    const editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n    if (editable == null) {\n        return false;\n    }\n\n    // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n    if (editable.tagName.toLowerCase() === \"input\") {\n        const inputType = (editable as HTMLInputElement).type;\n        if (inputType === \"checkbox\" || inputType === \"radio\") {\n            return false;\n        }\n    }\n\n    // don't let read-only fields prevent hotkey behavior\n    if ((editable as HTMLInputElement).readOnly) {\n        return false;\n    }\n\n    return true;\n}\n\nfunction getDefaultDocument(): Document | undefined {\n    if (typeof window === \"undefined\") {\n        return undefined;\n    }\n    return window.document;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}